# Теоретические билеты
## 1. Понятие компьютерной сети
Компьютерная сеть - совокупность компьютеров и прочего оборудования(периферия, маршрутизаторы  и т.д.), предназначенная для передачи компьютерной информации на относительно большие расстояния за пределами самих компьютеров

Любая КС может быть рассмотрена как совокупность программной и аппаратной части.

В основе любой КС лежит сеть передачи данных (СПД) — т.е сеть передачи данных (Data Communication Network), которая задействует различные среды передачи данных (СрПД).
Иногда в составе СПД выделяют базовую (опорную) СПД.

Все устройства в составе СПД можно разделить на:
- **End devices - периметр СПД**  (персональный компьютер, ноутбук, смартфон, планшет, принтер, сервер, роутер домашней сети, IP-телефон)
- **intermediary devices - “ядро” СПД**  (роутер, коммутатор (switch), маршрутизатор (router), брандмауэр (firewall), модем, многопортовый повторитель (hub), устройство балансировки нагрузки (load balancer), прокси-сервер)

![Selection_003](https://github.com/octolera/OKS/assets/106665253/d4665785-7019-4800-a966-3c4e7855e020)

Трафик в СПД разделяют на 
- обычные компьютерные данные - data
- голос - voice
- видео - video

В нотации Cisco сети способные посылать разнородный трафик называют конвергированными (converged networks)

Особенности трафика обеспечиваются качеством обслуживания **Quality of Service (QoS)**.
Традиционные данные обслуживаются по модели best efforts - все делается для доставки пакетов, но при этом ничего не гарантируется, т.е. фактически QoS отсутствует.
QoS присутствует при работе с голосом и видео

В рамках предоставляемой оборудованием СПД **полосы пропускания (bandwith)** можно выделить:
- throughput - реально задействованная часть
- goodput - полезная составляющая throughput без учета служебного трафика

## 2. Классификация компьютерных сетей
Среди КС выделяют:

- Local Area Networks (LANs) -- локальные КС (ЛКС). `Выделяют прежде всего территориально -- в современном понимании, охватывает территорию не более кампуса, но при этом подразумевают определенные технологии`
- Wide Area Networks (WANs) -- глобальные КС (ГКС). `Выделяют прежде всего технологически и, в общем случае, может охватывать произвольную территорию`
- Metropolian Area Networks (MANs) -- городские КС (устоявшейся русскоязычной аббревиатуры нет). `Представляет собой промежуточный вариант между LAN и WAN`
- Personal Area Networks (PANs) -- личные КС (устоявшейся
аббревиатуры нет). `Позволяет подключить к компьютеру периферийные устройства`
- Remote Access Services (RASes) -- КС для подключения удаленных пользователей (teleworkers) (так же устоявшейся аббревиатуры нет). `RAS существует в контексте WAN`
- Industrial Networks -- промышленные КС.
- Datacenter Networks -- КС центров обработки данных.
    
    `Industrial и Datacenter Networks являются специализированными
    вариантами LAN`
    

Также выделяют:

- Intranets - внутреннние КС организаций и предприятий. `Обычно выделяют по ведомственной принадлежности пользователей.`
- Internets - КС публичного доступа. `Практически все Internets сейчас интегрированы в одну сборную
одноименную сеть.`

`Intranet почти всегда имеет связь с Internet`

Сети могут быть:
- isolated (изолированными)
- open (открытыми для прослушивания)

С точки зрения организации сети могут быть:
- сильносвязанными
- слабосвязанными

**Сильносвязанная** КС предполагает наличие наличие **хост-ЭВМ (host)** с одной стороны и **терминала (terminal)** -- с другой. Хост является основным вычислительным компонентом. Под терминалами подразумевают исключительно устройства для ввода и отображения информации, следовательно, они без хоста бесполезны. 

Совокупность хоста и подключенных к нему терминалов принято называть **рабочей станцией (workstation)**. 
Терминал администратора, обычно подключаемый особым образом, называют **консолью (console)**.

`Мы имеем дело с хост-терминальной моделью`

**Слабосвязанная** КС предполагает наличие **сервера (server)** с одной стороны и **клиента (client)** -- с другой.

Клиентские ЭВМ, обслуживающие запросы пользователей, являются **активными компонентами**.

Сервер либо серверы, являющиеся пассивными компонентами, в свою
очередь, обслуживают запросы клиентов. Как клиенты, так и серверы могут работать независимо, связываясь по
мере надобности.

`Мы имеем дело с клиент-серверной моделью`

Технически не входит в состав билета, но было в материале:
```
С точки зрения общей организации работы сетевых устройств, в первую очередь касательно WANs и RASes, принято
выделять два типа оборудования:
  1. Оконечное оборудование данных (ООД) -- Data Terminal Equipment (DTE).
  2. Аппаратура передачи данных (АПД) -- Data Communication Equipment или, по-другому, Data Circuit-terminating
Equipment (DCE).

Термины происходят из традиционной телефонии.

ООД находится на самой границе СПД и «концентрирует», то есть создает и потребляет передаваемые информационные
потоки.
АПД находится в пределах СПД и «транслирует», то есть позволяет передавать и принимать информационные потоки.
Разница заключается и в синхронизации передаваемых потоков.
Первоисточником синхронизации обычно является АПД.
Понятие ООД хорошо соотносится с понятием оконечных устройств, а понятие АПД хорошо соотносится с понятием устройств-
посредников. Но, поскольку, термины ООД и АПД связаны с определенными технологиями, а задействующие эти технологии
устройства часто встречаются в самых разных частях СПД, знаки равенства ставить некорректно.
```

## 3. Стандарты компьютерных сетей
Все стандарты, в том числе в области КС, делят на:
 - Международные (например, ISO/IEC).
 - Европейские (например, EN).
   - Американские (например, ANSI/TIA/EIA).
Стандарты лишь формализуют определенные требования в той или иной предметной области.

Стандарты могут носить **предварительный (preliminary)** или **временный (interim)** характер. Могут включать **дополнения (annexes, addendums = addenda)** и **списки обнаруженных ошибок (errata)**. Могут **устаревать или замещаться другими стандартами (obsolete)**.

**Практическим (или теоретическим) воплощением** стандарта является так называемая **реализация (implementation)**.

**Сертификация (certification)** позволяет определить факт соответствия стандарту.
В 1980 г. при IEEE был создан специальный комитет по стандартизации КС, результатом работы которого стало множество стандартов `802.x`

Сейчас наибольший интерес представляют:
- `802.3` -- Ethernet.
- `802.11` -- Wi-Fi.
- `802.16` -- WiMax.
  
Стандарты Ethernet по пропускной способности делят на три группы:
- Ethernet -- до 10 Mbit/s включительно.
- Fast Ethernet -- 100 Mbit/s.
- Gigabit Ethernet -- 1, 10, 100, 40, 25 Gbit/s и Multigigabit.

Повсеместное внедрение ЛКС привело к необходимости их интеграции в инфраструктуру зданий и сооружений.

**Структурированная кабельная система (СКС) -- Structured Cabling System (SCS)** -- представляет собой упорядоченную гетерогенную коммуникационную подсистему зданий и сооружений.

Выделяют следующие стадии работ, связанных с СКС, для каждой из которых предусмотрен собственный набор стандартов:
- Проектирование.
- Монтаж.
- Эксплуатация.
  
## 4. Наиболее распространенные модели компьютерных сетей
Из всех моделей КС основной является **открытая модель взаимодействия систем - Open System Interconnection (OSI)**, разработана ISO.

Модель включает в себя 7 уровней:

![Selection_004](https://github.com/octolera/OKS/assets/106665253/2b0ec63f-345d-470d-8dae-1b9f1a4c042a)

`На вершине иерархии находится человек.`
`Абонентами КС являются взаимодействующие программы`

## 5. Физический уровень модели OSI
На физическом уровне формализуют подключение сетевого устройства к СрПД. **Соответственно в пространстве физический уровень охватывает «точку» подключения.**
Специфическими понятиями физического уровня являются:
- среда;
- разъем (физический порт);
- несущая (частота);
- модуляция;
- сигнал.

Фундаментальная задача физического уровня заключается в **передаче сигнала**.

## 6. Канальный уровень модели OSI
На канальном уровне (datalink) формализуется **взаимодействие станций в пределе сегмента**.

**Станция или узел (node)** - любое устройство, способное передавать или принимать сетевой трафик - пк, сервер, маршрутизатор и т.д.
Физически любая КС состоит из **сегментов** - множества станций обьединенных посредством одной СрПД и "видящих" друг друга непосредственно. Технологическая реализация сегментов может отличаться.

В традиционном понимании СрПД соответствует **физическому соединению (link)**. Однако многие современные технологии предполагают наличие в СрПД "прозрачных" устройств- посредников (преобразователей и коммутаторов).

Специфическими понятиями канального уровня являются:
- сегмент сети
- физическая и логическая топология сегмента
- пакет (кадр)
- бит- и байт-стаффинг
- адресация в пределах сегмента
- канальный код
- код проверки целостности пакета (кадра)
- алгоритм доступа к моноканалу

Каждый из уровней модели OSI может быть реализован достаточно сложно, но канальный уровень особенно сложен. Поэтому его разделяют на два подуровня:
- **MAC (Media Access Control)** -- контроль доступа к СрПД.
- **LLC (Logical Link Control)** -- контроль логического соединения.

**На подуровне MAC, более низком,** выполняется взаимодействие с физическим уровнем, то есть средозависимые операции, такие как формирование и распознавание пакетов, адресация, канальное кодирование и другие.

**На подуровне LLC, более высоком,** выполняется взаимодействие с сетевым уровнем, то есть средонезависимые операции, такие как разбиение данных на пакеты, сборка данных из пакетов, определение соответствующей подсистемы сетевого уровня и другие.
  
## 7. Сетевой уровень модели OSI
`Сетевой уровень позволяет «выйти» за пределы сегмента.`

### На сетевом (network) 
уровне формализуют построение полноценной КС произвольного масштаба, охватывающей произвольное количество сегментов.

Специфическими понятиями сетевого уровня являются:
- пакет (собственно пакет)
- адресация в пределах всей КС
- маршрутизация.

## 8. Транспортный и сеансовый уровни модели OSI
**Транспортный уровень** позволяет перейти от оборудования к программам. На **транспортном (transport)** уровне формализуют использование программным обеспечением сетевого оборудования, то есть как отдельно взятым программам предоставляется «транспорт».

Специфическими понятиями транспортного уровня являются:
- пакет (сегмент сообщения)
- программный порт
- логическое соединение
- надежность доставки
- алгоритм борьбы с заторами в СПД.

### Сеансовый или сессионный (session) 
уровень позволяет предоставить доступ к транспорту всем программам в многозадачном окружении.

Кроме собственно сессии, имеются еще два основных специфических понятия сеансового уровня:
- программный порт
- алгоритм мультиплексирования программ.

В практических реализациях сеансовый уровень выражен слабо и обычно совмещается с транспортным.

## 9. Прикладной уровень и уровень представления модели OSI
### Прикладной (application)
уровень призван решать конкретные пользовательские задачи с помощью КС.

Примерами прикладных задач могут служить:
- пересылка файлов между компьютерами
- пересылка электронных писем
- поддержка удаленных текстовых и графических терминалов, в том числе для администрирования
- пересылка мультимедийных документов
- обмен «мгновенными» сообщениями
- совместная разработка чего-либо
и другие.

Плюс, выделяемые особо, как несвойственные традиционным компьютерным сетям, задачи пересылки голоса и видео в реальном времени. `При этом, QoS «возникает» и на всех нижестоящих уровнях`. 

Специфических понятий прикладного уровня великое множество и они зависят от решаемых задач.

### Уровень представления (presentation) 
позволяет адаптировать прикладную информацию в форму, приемлемую для передачи по КС, то есть является прослойкой между программами и транспортом

Основными задачами уровня представления являются:
- кодирование информации (включая возможное сжатие) с целью обеспечения ее правильной интерпретации в последующем;\
- шифрование информации с целью обеспечения ее защиты при пересылке по открытым для прослушивания сетям
  
`Поскольку обычно уровень представления «привязан» к прикладному уровню, в реализациях эти уровни часто совмещаются`.

Взаимодействие в рамках модели OSI может быть «вертикальным» и «горизонтальным»:
- **Интерфейс (interface)** -- это правила взаимодействия между пространственно совмещенными соседними уровнями модели OSI.
- **Протокол (protocol)** -- правила взаимодействия между пространственно разнесенными одинаковыми уровнями модели OSI.
И в том, и в другом случае предполагают определенную абстракцию.

## 10. Семейство протоколов TCP/IP
Исторически сложились два основных семейства протоколов:
- TCP/IP.
- IPX/SPX.

В настоящее время TCP/IP полностью доминирует. IPX/SPX почти не используют

![Selection_005](https://github.com/octolera/OKS/assets/106665253/a0cb5c54-5837-480d-b881-6a9a4413f466)

`Семейство протоколов TCP/IP описано в стандартах RFC (Request For
Comments)`.

С семейством протоколов TCP/IP связана одноименная модель. Cопоставление с моделью OSI:

![Selection_006](https://github.com/octolera/OKS/assets/106665253/335c673f-8fca-4df3-94bf-e33c3cbd7a47)

## 11. Эволюция COM-портов и их место в современных устройствах
История развития **последовательного (serial)** или, по-другому, **коммуникационного (COMmunication)** порта неразрывно связана с развитием элементной базы.

Применительно к ПК разработчиком как базовой архитектуры так и типовых схем оборудования являлась и до сих пор является компания Intel.

В развитии COM-порта ПК можно выделить следующие основные этапы (следует отметить, что этот процесс сильно коррелирует с развитием COM-портов всех типов компьютерных систем):

- В свое время (семидесятые годы XX века), в составе периферийной части комплекта микросхем поддержки микропроцессора 8080, компания Intel разработала два контроллера последовательного порта. Один из них, `8250`, получил название `UART (Universal Asynchronous Receiver/Transmitter)` - универсальный асинхронный приемник-передатчик.

- Второй, `8251`, получил название `USART (Universal Synchronous/Asynchronous Receiver/Transmitter)` - универсальный синхронно-асинхронный приемник-передатчик.

Эти контроллеры были рассчитаны на подключение по шине X-Bus (шина ввода-вывода, внутрисхемный восьмибитный предшественник системной шины ISA) и поэтому без труда были перенесены в первые ПК на базе процессора 8086 и его модификаций (то есть компьютеры класса IBM PC XT) с тогда наиболее распространенной системной шиной ISA.

Совместно с контроллером параллельного порта `8255`, микросхема `UART` либо `USART` устанавливалась на плату специального адаптера и подключались к материнской плате ПК посредством разъема системной шины.

В это же время возникла традиция устанавливать последовательные порты парами (COM1 и COM2).

### Времена доминирования процессоров 80286 -- Intel486 (то есть компьютеры класса IBM PC AT и IBM PS/2) ознаменованы постепенно набравшими силу интеграционными процессами.

На первом этапе происходило распространение и развитие самих контроллеров.

В СССР был создан аналог 8251 под названием `КР580ВВ51А`, который и стал массово применяться в серии ЕС ПК.

На Западе же, наоборот, развитие получила микросхема `8250`.

Апофеозом достаточно быстрого усовершенствования `8250` стали несколько UART, среди которых следует выделить `16550`, причем это была разработка уже не Intel, а National Semiconductor. Именно эта микросхема стала де факто стандартной на длительное время (архитектурная совместимость сохраняется вплоть до настоящего времени). `16550` имеет два основных преимущества перед `8250`: 
- более высокая пропускная способность последовательного интерфейса (максимальная стандартная пропускная способность увеличена с 9600 baud до 115200 baud)
- возможность буферизации (две очереди FIFO по 16 байт -- на стороне передатчика и на стороне приемника).

В дальнейшем интеграционные процессы привели к появлению так называемых `мультикарт` -- подключаемых посредством разъема системной шины (по-прежнему обычно ISA) плат расширения с интегрированными контроллерами: последовательного порта (2x16550), параллельного порта, игрового порта, НГМД и НЖМД. Причем все **эти функции сочетались в одной
БИС с типичным названием Multi I/O**. 

Основными производителями чипов Multi I/O были компании Winbond, UMC, GoldStar и другие.

`Для ПК на базе поздних Intel486 уже была характерна интеграция чипа Multi I/O на материнскую плату`.

### Во времена процессоров Pentium сформировалась действительная до сих пор базовая крупноблочная структура материнской платы ПК, состоящая из четырех основных БИС

![Selection_007](https://github.com/octolera/OKS/assets/106665253/bdd163c2-4ef4-4fc7-a0fa-782ada44a671)

Контроллеры последовательного порта (по той же схеме 2x16550) в составе интегрированной периферии были перенесены и в эту структуру.

После перехода от `мостовой (bridges)` организации ПК к `хабовой (hubs)` в рамках данной структуры (начиная с восьмисотой серии чипсетов Intel в эпоху Pentium III) `для внутрисхемного подключения Super I/O вместо шины X-Bus
стала использоваться шина LPC (Low Pin Count)` -- специализированная разновидность шины PCI с небольшим числом разрядов.

```
В настоящее время (приблизительно с 2005 года) традиционный последовательный интерфейс ПК считают устаревшим (legacy), часто исключают из состава интегрированной периферии -- на материнских платах можно увидеть все реже.

Сейчас в качестве основного последовательного интерфейса ПК
рассматривают шину USB (Universal Serial Bus), впервые введенную в состав
ПК еще в эпоху процессоров Pentium.
```
## 12. Структура COM-порта
Сам факт передачи информации подразумевает наличие передатчика, приемника и канала, по которому они связаны. Как и следует из названия, UART 16550 сочетает в себе функции как приемника, так и передатчика. 

Предоставлена возможность подключения к двунаправленному каналу связи в соответствии со стандартом RS-232. На аппаратном уровне приемник и передатчик работают **параллельно**, то есть **по отдельным физическим цепям полностью независимо друг от друга**.

Структурная схема UART 16550.

![Selection_008](https://github.com/octolera/OKS/assets/106665253/173ee55e-ed02-43b6-af1e-be508245a20b)

Интерфейс RS-232 (традиционное название, последнюю редакцию 1997 года правильно называть TIA-232-F, существуют и другие названия) предназначен для подключения АПД (например, модема) к ООД (например, UART).Для физического подключения по стандарту RS-232 используют девятиконтактные разъемы D Subminiature (D-sub) DE-9. В старых ПК класса IBM PC использовали и аналогичные двадцатипятиконтактные разъемы DB-25.

Принято, что штырьевую часть разъема устанавливают со стороны ООД, а гнездовую часть -- со стороны АПД.

Согласно PC System Design Guide, с 1999г. разьёмы последовательных портов окрашивают в бирюзовый цвет.

## 13. Цепи RS-232 и их использование
### Традиционное назначение цифровых цепей RS-232
- `SOUT` (Serial Output) -- выход передатчика;
- `SIN` (Serial Input) -- вход приемника;
- `RTS` (Request to Send) -- сигнал-запрос от UART к модему о передаче байта;
- `CTS` (Clear to Send) -- сигнал-подтверждение от модема к UART о готовности принять байт для передачи;
- `DSR` (Data Set Ready) -- сигнал от модема к UART о готовности к взаимодействию;
- `DTR` (Data Terminal Ready) -- сигнал от UART к модему о готовности к взаимодействию;
- `DCD` (Data Carrier Detect) -- сигнал от модема к UART об обнаружении данных;
- `RI` (Ring Indicator) -- сигнал от модема к UART об обнаружении входящего телефонного звонка.

Служебные цепи RS-232 позволяют организовать `контроль информационного потока (flow control)`. Например, это позволяет избегать переполнения приемника, приостанавливая «быстрый» передатчик. Следует отметить, что практически все служебные цепи напрямую связаны с соответствующими регистрами управления и состояния UART 16550, то есть «открыты» для программирования. Следовательно, алгоритмы контроля реализуют программно и закладывают, например, в драйверы операционных систем. Контроль может быть как полуаппаратным (с задействованием сигналов RS-232), так и сугубо программным. 

Очевидно, что традиционное использование пары `RTS/CTS` позволяет контролировать передачу только в одном направлении -- `от UART к модему`. Для контроля передачи `в обратном направлении` использовалась пара `DSR/DTR`.

В большинстве современных реализаций контроль по прежнему предполагает наличие обратной связи, но осуществляется только приемником. Два основных метода:
- `RTS/CTS` -- полуаппаратный.
- `XON/XOFF` -- программный.
UART контролирует передачу данных «к себе» управляя активностью цепи `RTS`, модем -- `CTS`.
Значительно реже применяют метод `DTR/DSR` -- полностью аналогичен  методу `RTS/CTS`, но значения сигналов сохраняются на протяжении всего информационного обмена, а не каждой посылки.

При полностью программном контроле, приемник передает в обратном направлении специальный байт `XON` (стандартное значение 11h) для инициирования передачи и специальный байт `XOFF` (стандартное значение 13h) для остановки передачи.

В стандартной ситуации, **ООД взаимодействуют между собой посредством АПД**, причем с помощью так называемых «рукопожатий» (handshaking) с АПД. При этом подключение АПД к ООД осуществляют `посредством «прямого» кабеля (straight-through cable)`.
Для подключения **двух ООД друг к другу** непосредственно необходим один из вариантов `нуль-модемного (null-modem, поскольку предполагают отсутствие модема) кросс-кабеля (crossover cable, поскольку цепи SIN и SOUT скрещивают)`.

`Для изготовления кросс-кабеля нужны минимум три провода.`

![Selection_009](https://github.com/octolera/OKS/assets/106665253/374159dc-c575-490a-b0bd-ccfce22d5ae0)

```
Иногда программное обеспечение рассчитано только на использование модемов. В подобных ситуациях, для непосредственного подключения двух ООД необходимо «закоротить» соответствующие пары сигналов.

Часто в литературе приводят еще одну схему нуль-модемного кабеля, в соответствии с которой роль модема играет ООД-абонент.

При этом нужно иметь в виду, что в информационных системах принято все «мерить» относительно человека, в том числе и ввод-вывод. Таким образом, в ПК направление определяется «с точки зрения» центрального процессора, а в данном случае -- «с точки зрения» ООД.
```
## 14. Асинхронный режим работы COM-порта
**Асинхронный (asynchronous)** -- синхронизируется посылка каждого информационного байта.

![Selection_010](https://github.com/octolera/OKS/assets/106665253/c27b2dd3-4eef-470c-ab41-da0329075f7a)

**Атомарной, то есть минимальной неделимой единицей**, с которой работает как UART, так и USART, является байт, причем один байт не обязательно равен восьми битам и может содержать от `5` до `8` битов. 

По умолчанию линия находится в состоянии логической единицы.
При наличии байта для передачи передатчик переводит линию в состояние логического нуля, то есть передает старт-бит, что говорит приемнику о том, что на следующем такте нужно «ловить» первый информационный бит.
`Стоп-бит` необходим для того, чтобы после передачи информационной последовательности гарантированно вернуть линию в исходное, то есть единичное состояние.
`Старт-бит` всегда **один**, а стоп-битов может быть **один, полтора либо два**.

Для проверки целостности информационной части, **если эта проверка включена**, за информационной частью вставляется `бит паритета`. При этом действует правило дополнения. Например, если включена проверка единиц на четность (even), то бит паритета формируется таким образом, чтобы общее число единиц (в информационной части плюс бит паритета) было четным. Либо, если включена проверка нулей на нечетность (odd), то общее количество нулей должно быть нечетным. 

Ошибки отслеживаются приемником.

## 15. Синхронный режим работы COM-порта
**Синхронный (synchronous)** -- синхронизируется весь информационный
обмен.

![Selection_011](https://github.com/octolera/OKS/assets/106665253/f02bede9-8ae9-482a-a38f-c4867905643c)

При «простое» передатчик заполняет линию специальными `байтами синхронизации`, тем самым настраивая приемник.

`Все поступающие байты передаются без «обрамления».`

Как и в асинхронном режиме, ошибки отслеживаются приемником. При обнаружении ошибок, а при длительной непрерывной передаче из-за накапливающихся фазовых сдвигов они неизбежно возникают, приемник должен каким-либо дополнительным способом (так как текущую линию задействовать невозможно) приостановить передатчик, чтобы канал вновь заполнился байтами синхронизации.

## 16. Тактирование COM-порта
По своей сути, передатчик и приемник COM-порта представляют собой `программируемые сдвиговые регистры`.

Данные, предварительно записанные в регистр передатчика параллельно, затем последовательно сдвигаются в канал под воздействием тактовых импульсов. В процессе работы UART 16550 тактирование сдвиговых регистров осуществляется непрерывно. Следовательно, данные начинают поступать в канал сразу после их записи в регистр передатчика. 

Заполнение регистра приемника так же происходит «автоматически». Если передаваемые байты записываются слишком быстро, то возникает переполнение очереди FIFO передатчика. Если принимаемые байты считываются слишком медленно, то после переполнение очереди FIFO приемника происходит их потеря.

Тактирование сдвиговых регистров UART 16550 осуществляется с помощью встроенного программируемого `бод-генератора (baud generator)` (тактирование некоторых первых реализаций UART осуществлялось таймером).
Бод-генератор представляет собой **программируемый делитель частоты**.

Выходная частота `бод-генератора Fout` определяется по формуле:
    
    `Fout = Fin / (16 DL)` 
    
где:
    
    `Fin` -- входная частота,
    
    `DL` -- шестнадцатибитная константа, старшая и младшая части которой хранятся в двух регистрах UART (DLL и DLM).

На вход бод-генератора **поступает меандр, получаемый от внешнего кварцевого резонатора**, который тактирует и сам автомат UART. Частота тактирования автомата UART **по крайней мере в 16 раз больше** `Fout`. 

Следует учитывать, что, для того чтобы правильно рассчитать `DL`, необходимо точно знать `Fin`.

Вполне естественно, что на разных материнских платах используют разные микросхемы и разные кварцевые резонаторы. Применительно к современным Super I/O, эта частота может достигать 48 MHz, то есть
совпадать с частотой синхронизации Super I/O. Но, за счет **еще одного деления частоты** (при загрузке ПК BIOS конфигурирует UART инициализируя соответствующие регистры конфигурационного пространства Super I/O), как правило, `Fin` приводится к классическому значению 1,843 MHz.

При этом, если `DL` = 1 (нулевое значение `DL` использовать крайне не рекомендуется), то `Fout` = 115200 Hz.2.0.2.14

Пропускную способность последовательных каналов связи принято оценивать в бодах.

`Один бод (baud) равен одному сигналу в секунду.`

В случае с UART 16550 производительность, измеренная в бодах, совпадает с производительностью, измеренной в битах в секунду (bit/s равно bps). 

## 17. Архитектура COM-порта

`UART 16550`, как и вся БИС Super I/O, как и любая БИС на материнской плате, является **низковольтной**. Но в интерфейсе `RS-232` значения логических уровней совершенно другие, **значительно более «разнесенные»**, что позволяет передавать данные на расстояние до нескольких десятков метров. 

Для получения необходимых значений используют специализированные преобразователи уровней `75232` (аналоги: 75185, 6571 и другие).

Преобразователь уровней `75232` фактически играет роль `трансивера (transceiver, transmitter плюс receiver)`, сочетая функции приемника и передатчика в интерфейсе с определенной физической средой, которой в данном случае является `RS-232`).

![Selection_012](https://github.com/octolera/OKS/assets/106665253/344f07fe-9559-43e7-acbf-1226f0022125)

```
В больших ЭВМ производства второй половины прошлого века для подключения терминалов применялись другие трансиверы -- трансиверы токовой петли (current loop), которые не «разносят» уровни напряжений, а моделируют токовые посылки, что позволяет увеличить расстояние передачи.

Возможность использования токовой петли в ПК была отвергнута изначально.
```

Как и любое устройство ввода-вывода, `UART 16550` содержит регистры управления, регистры состояния, плюс информационные регистры. В стандартной архитектуре ПК для `СOM1` и `COM2` зарезервированы следующие диапазоны программных портов в адресном пространстве ввода-вывода процессора: 

3F8h -- 3FFh и 2F8h -- 2FFh соответственно (но возможности Super I/O позволяют сконфигурировать UART 16550 нестандартно).

Регистры UART 16550 отображаются в соответствующий диапазон следующим образом. Отображение частично зависит от значения `Divisor Latch Access Bit (DLAB)` -- самого старшего (седьмого) бита регистра `LCR`.

Прикладная программа должна в первую очередь корректно **инициализировать соответствующие регистры** `UART`. При этом предоставлена возможность работы по прерываниям. Стандартными аппаратными прерываниями `COM1` и `COM2` являются `IRQ4` и `IRQ3` соответственно (также можно изменить)


![Selection_013](https://github.com/octolera/OKS/assets/106665253/18ce86b5-40b4-450e-b5fd-f7ef71183946)

Назначение регистров:
- `THR (Transmit Holding Register)` -- регистр данных передатчика (точнее буферный регистр сдвигового регистра передатчика).
- `RBR (Receiver Buffer Register)` -- регистр данных приемника (точнее буферный регистр сдвигового регистра приемника).
- `DLL (Divisor Latch Least significant byte)` -- младшая часть константы деления бод-генератора.
- `DLM (Divisor Latch Most significant byte)` -- старшая часть константы деления бод-генератора.
- `IER (Interrupt Enable Register)` -- регистр разрешения прерываний.

    ![Selection_021](https://github.com/octolera/OKS/assets/106665253/5571b72a-081f-47da-911a-dd5421597904)

- `IIR (Interrupt Identification Register)` -- регистр идентификации прерываний.

    ![Selection_019](https://github.com/octolera/OKS/assets/106665253/b9997673-8c2f-4ad1-83c2-68a1d7e34cc9)

  Прерывания UART 16550
  
    ![Selection_020](https://github.com/octolera/OKS/assets/106665253/3decd2b9-5bb6-49d3-90fe-1a182966b8e3)

- `FCR (FIFO Control Register)` -- регистр управления очередями FIFO передатчика и приемника.

    ![Selection_018](https://github.com/octolera/OKS/assets/106665253/fb26cb26-9f13-4575-a7ed-60d63d347205)

- `LCR (Line Control Register)` -- регистр управления линией.

    ![Selection_017](https://github.com/octolera/OKS/assets/106665253/e59110aa-464b-410a-a829-a1b0a7309662)

Включение «залипания» `бита паритета (sticky parity)` приводит к передаче соответствующего константного значения. Включение паузы приводит к приостановке передатчика. При этом передатчик удерживает линию в состоянии логического нуля длительное время, что автоматически переводит в режим паузы и приемник (без уведомления об ошибках).

- `MCR (Modem Control Register)` -- регистр управления модемом.

    ![Selection_016](https://github.com/octolera/OKS/assets/106665253/a3fcde1b-c8ba-4d37-aa1a-d05182553efc)

Включение `loopback-режима` приводит к «закорачиванию» выхода передатчика и входа приемника, что может применяться с целью тестирования `UART`.

- `LSR (Line Status Register)` -- регистр состояния линии.

    ![Selection_015](https://github.com/octolera/OKS/assets/106665253/62e473a2-4cd7-4fc9-8ae0-1013ef52d840)

После считывания очередных данных из приемника нулевой бит `LSR` обнуляется.
После записи очередных данных в передатчик обнуляются пятый и шестой биты `LSR`.
Остальные биты обнуляются после чтения `LSR`.

- `MSR (Modem Status Register)` -- регистр состояния модема.

    ![Selection_014](https://github.com/octolera/OKS/assets/106665253/82703db1-bf1c-462b-92cc-850b59f29a02)

- `SCR (Scratch Pad Register)` -- дополнительный регистр для временного хранения данных, не связанный с функционированием UART.

## 18. Стандарты, близкие к RS-232
С точки зрения топологии, интерфейс `RS-232` обладает одним существенным ограничением, которое закономерно вытекает из его природы.

Он изначально задумывался как интерфейс между разноранговыми устройствами, то есть, по сути дела, как интерфейс для подключения периферийных устройств к компьютеру. **Более двух устройств с помощью RS-232 объединить невозможно**.

В результате, закономерным продолжением стандарта `RS-232` стали два стандарта: `RS-422 (EIA-422-B)` и `RS-485 (EIA-485)`. При этом `RS-422` можно рассматривать как промежуточный на пути к `RS-485` стандарт.

![Selection_022](https://github.com/octolera/OKS/assets/106665253/f8e89950-b4fc-4e46-a40f-ed09c837a1ca)

Для передачи данных посредством интерфейса `RS-485` требуются специальные **трансиверы с гальванической развязкой**, позволяющие реализовать дифференциальный способ передачи сигнала.
**Гальваническая развязка** может быть либо **трансформаторной**, либо **оптронной**.
О СрПД в стандарте не сказано, но, как правило, используют `витую пару (twisted pair)` и разъемы типа `RJ`.

## 19. Структура типового пакета компьютерной сети
Из-за более простой реализации последовательного метода он используется для передачи данных между станциями. Внутри станций используется параллельная обработка.

Для именования порции информации, передаваемой по каналам компьютерных (и не только компьютерных) сетей, используют обобщенный термин `пакет (packet)`.
Пакет содержит последовательно сформированные станцией-передатчиком `поля (fields)`, предназначенные для их интерпретации в станции-приемнике. В общем случае, пакеты могут быть самыми разнообразными (как по структуре, так и по длине), но подавляющее большинство пакетов подпадают под типовую структуру.

Назначение полей:
----Начало----------------------------------------------------------------------
----Header----------------------------------------------------------------------
- `Flag` -- флаг, точнее, флаг начала пакета -- позволяет определить начало пакета.
- `Destination Address` -- адрес назначения -- позволяет указать станцию, для которой предназначен пакет.
- `Source Address` -- адрес источника -- позволяет указать станцию, сгенерировавшую пакет.
- `Other Fields` -- прочие поля -- специфические поля (в том числе и специфические флаги) определенной реализации.
----Payload----------------------------------------------------------------------
- `Data` -- данные -- «полезное» наполнение пакета.
----Trailer----------------------------------------------------------------------
- `FCS (Frame Check Sequence)` -- контрольная сумма -- позволяет проверить целостность пакета.
----Конец----------------------------------------------------------------------

Обычно в байт-ориентированных реализациях длина пакета кратна восьми битам, то есть пакет состоит из так называемых `октетов (octets)`.

Все поля в составе любого пакета можно условно разделить на полезные и служебные.

Полезная `нагрузка (payload)` заключается в собственно данных. Но следует понимать, что вкладываемая в качестве данных информация может носить служебный характер. В некоторых пакетах поле данных не предусмотрено вообще.

Сколько дополнительного трафика порождается в связи с наличием служебных полей оценивают как `overhead`

## 20. Инкапсуляция и ее проявления в компьютерных сетях
В соответствии с концепцией модели OSI, соседние уровни абстрагированы друг от друга. Поэтому вполне закономерно, что на каждом уровне работают со своими структурами данных. При продвижении информации между уровнями возникает необходимость в преобразованиях структур данных. Преобразования выражаются в `инкапсуляции` и `декапсуляции`.

Под `инкапсуляцией (encapsulation)` в КС понимают вкладывание пакета определенного вышестоящего уровня в поле данных пакета смежного нижестоящего уровня в процессе подготовки к передаче, то есть при продвижении сверху вниз. 

Под `декапсуляцией (decapsulation)` понимают обратное действие после приема, то есть при продвижении снизу вверх.

Функционал любого из вышестоящих уровней «знает», какие нижестоящие ресурсы ему необходимы и чем он «располагает». Поэтому процесс инкапсуляции не доставляет трудностей.
А вот функционал нижестоящего уровня при разборе полученных пакетов заранее не знает, какой из вышестоящих подсистем передавать эти пакеты. Проблему решают введением в структуру пакета `служебного поля`, **в котором записывается код протокола вышестоящего уровня**.

Важной особенностью инкапсуляции является то, что в большинство реализаций заложена возможность передавать пакеты, относящиеся к некоторому протоколу некоторого уровня (например, сетевого), вкладывая их в пакеты другого протокола того же уровня, то есть организовывать `туннелирование (tunneling)`.

Инкапсуляция имеет еще ряд проявлений.

Если при выполнении инкапсуляции данные некоторого уровня не помещаются в поле отведенной длины, то можно прибегнуть к `фрагментации (fragmentation)` -- разбить данные на фрагменты и передать цепочку пакетов. Принимающая сторона будет вынуждена выполнить `дефрагментацию (defragmentation)`.
Поле, отвечающее за длину поля данных, может быть не предусмотрено. Если длина поля данных фиксирована, а данных не хватает, то возникает необходимость в `автодополнении` (например, нулями).

`Перемежение (interleaving)` позволяет «распараллелить» пересылку пакетов или их фрагментов и заключается в одновременном задействовании нескольких каналов.
Особенно это применимо в низкоскоростных СрПД. 
`Фрагментация` (при наличии альтернативных путей в СПД) и `перемежение` могут привести к «перемешиванию» пакетов и, как следствие, **разрушению сообщения**.

Контроль за порядком фрагментов может быть возложен как на **протокол подверженного фрагментации уровня**, так и на **протокол вышестоящего уровня**.

Названия структурных единиц передаваемой информации в привязке к уровням модели OSI:
- L1 -- сигналы (signals).
- L2 -- кадры (frames).
- L3 -- собственно пакеты (packets).
- L4 + L5 -- сегменты (segments).
- L6 + L7 -- сообщения (messages).
## 21. Бит-стаффинг
При `бит-стаффинге` совпадающая с флагом последовательность разбивается с помощью вставки дополнительно бита с соответствующим значением.

`Реализуется аппаратно. Обычно применяется при задействовании синхронных СрПД`

Применение `бит-стаффинга` приводит к увеличению длины пакета. Теоретически, с целью уменьшения связанных с бит-стаффингом «издержек», следует стремиться к минимизации количества вставок: разбивающий бит нужно вставлять после наиболее длинной уникальной подпоследовательности в флаговой последовательности.

Классическим флагом начала пакета является байт со значением 01111110b (7Eh).

![Selection_023](https://github.com/octolera/OKS/assets/106665253/21d80ecd-6ac9-4911-8243-fab8aed810ef)

На передающей стороне после нуля и шести единиц всегда вставляется седьмая единица, а на принимающей стороне единица после нуля и шести единиц всегда удаляется.

```
Следует отметить, что на практике (например, применительно к HDLC) бит-стаффинг выполняется вставкой нуля после пяти единиц.
```

## 22. Байт-стаффинг
`Реализуется программно. Обычно применяется при задействовании асинхронных СрПД`

В сравнении с алгоритмами бит-стаффинга, алгоритмы байт-стаффинга манипулируют байтами, являются более сложными и более «затратными», но при программировании они позволяют избежать битовых операций.

![Selection_024](https://github.com/octolera/OKS/assets/106665253/74673860-905e-432f-a24d-655890148cef)

Единственным способом обеспечения уникальности флагового байта является замена совпадающего с ним байта на некий выбранный другой. Но возникает вопрос, как принимающая сторона отличит замененный байт от такого же незамененного. Решением является применение так называемого `ESC-символа`. Наличие `ESC-символа` говорит станции-приемнику о факте замены, а следующий за `ESC-символом` символ -- код замены позволяет определить какая замена была осуществлена. Байт-стаффингу можно подвергать **целые группы символов**.

## 23. Особенности линейного кодирования и классификация линейных кодов, применяемых в компьютерных сетях
Не следует путать линейное кодирование с модуляцией, выполняемой на физическом уровне. Несмотря на то, что часто эти процессы связаны неразрывно, **линейное кодирование все-таки следует рассматривать как надстройку над модуляцией**.

Одной из основных предпосылок для разработки линейных кодов, является проблема, проявляющаяся во многих системах передачи цифровой (не только) информации, известная как девиацией несущей (carrier deviation). Очевидно, передатчик и приемник должны работать на одной частоте. В большинстве случаев, передатчик и приемник имеют разные источники
синхронизации. При этом тактовые генераторы далеко не идентичны. Если состояние линии очень долго не изменяется, что происходит при передаче очень длинных нулевых либо единичных последовательностей с использованием классической амплитудной модуляции цифровых цепей (логический ноль соответствует земле, а логическая единица некоторому положительному потенциалу относительно земли), то приемнику «цепляться не за что». В результате накапливаются фазовые сдвиги, что в конце концов приводит к возникновению ошибок. 

Современная схемотехническая база для борьбы с девиацией несущей имеет в распоряжении блок `ФАПЧ (фазовой автоподстройки частоты)`, позволяющий автоматически подстраивать тактовый генератор приемника к тактовому генератору передатчика. 
Наиболее близкий англоязычный термин -- `PLL (Phased-Locked Loop)`.

Все линейные коды, в той или иной степени, **направлены на преобразование битовых последовательностей**, чтобы в линии постоянно происходили изменения. В том числе, за счет равномерного распределения нулей и единиц.

Шесть факторов, влияющих на классификацию линейных кодов:
1. Кодирование уровнями либо переходами.
2. Наличие инвертирования.
3. Однополярность либо многополярность.
4. Наличие так называемого «возврата к нулю».
5. Наличие самосинхронизации.
6. Наличие перестановки или подмены битов.

Линейные коды, применяемые в оптических каналах имеют особенности в сравнении с кодами для проводниковых каналов. 

Пример: 
- `TS-FO (Three of Six -- Fiber Optical)`, `RZ carrier-suppressed`, `RZ
alternate-phase`

## 24. Линейные коды без возврата к нулю и с возвратом к нулю
### NRZ
`NRZ`-коды выражаются в изменении уровней между тактами. В простейших случаях, логические уровни в исходной последовательности не преобразуются совсем либо инвертируются. Более сложными случаями являются `space` и `mark`. При `space`-варианте ноль во входной последовательности кодируется сменой текущего уровня в выходной, а единица -- сохранением текущего уровня. При `mark`-варианте, наоборот, единицы в исходной последовательности приводят к переключению уровней. Начальное состояние значения не имеет. `Space` и `mark` инверсны друг относительно друга. `NRZ`-коды могут быть однополярными и двухполярными. Требуется наличие дополнительной цепи для тактирования. 

![Selection_025](https://github.com/octolera/OKS/assets/106665253/7bf88aa2-cffd-4d13-a51b-04de6c05fa62)

Примеры технологий с применением `NRZ`-кодов: `RS-232`, `USB`, `HDLC`.

### RZ
`RZ`-коды так же выражаются в изменении уровней между тактами, но на половине каждого такта всегда происходит возврат к нулю (земле). Двухполярные RZ-коды обладают свойством самосинхронизации. Пример технологии с применением `RZ`- кода: `IrDA`.

![Selection_026](https://github.com/octolera/OKS/assets/106665253/d4f3a1db-2e9f-4d55-81f3-88e8195b0802)

## 25. Манчестерские и многоуровневые линейные коды
Манчестерские коды выражаются в переходах между уровнями во время тактов, поэтому их иногда называют фазовыми кодами.
Есть два «равноправных» варианта собственно манчестерского кода. Ноль во входной последовательности заменяется на переход от единицы к нулю, а единица заменяется на переход от нуля к единице. Либо наоборот.
**Манчестерские коды обладают свойством самосинхронизации**.

Еще несколько кодов близки к манчестерскому.
Согласно `коду Миллера (Miller)`, ноль соответствует отсутствию перехода во время такта, единица соответствует переходу во время такта, плюс между двумя нулями всегда выполняется смена уровня.

Согласно коду `Split Phase` учитывается направление предыдущего перехода. При `space`-варианте ноль соответствует переходу во время такта в направлении, противоположном направлению предыдущего перехода, единица соответствуют переходу во время такта в направлении, совпадающем с направлением предыдущего перехода. При `mark`-варианте
«роли» нулей и единиц из входной последовательности инвертируются. 

Согласно коду `Biphase`, кроме возможных переходов во время тактов, всегда выполняется смена уровня между тактами. При `space`-варианте ноль соответствуют переходу во время такта, единица соответствуют отсутствию перехода во время такта. При `mark`-варианте «роли» нулей и единиц из
входной последовательности инвертируются. 

Примеры технологий с применением манчестерских кодов: `Ethernet`, `Token
Ring`, некоторые `IR`-технологии.

![Selection_027](https://github.com/octolera/OKS/assets/106665253/0e3e1159-89f3-4732-bc89-97947d9b649f)

## 26. Блочные линейные коды
Блочные коды выражаются в замене блоков битов из входной последовательности на большие (как правило) по размеру блоки битов в выходной последовательности.Блочные коды могут комбинироваться с вышеперечисленными кодами. 

В связи с избыточностью блочных кодов, во многих из них предусмотрены контрольные последовательности, которые, по сути, являются управляющими символами.
Первым примером может служить код `4b/5b`, применяемый в `Fast Ethernet` и `CDDI`.

![Selection_028](https://github.com/octolera/OKS/assets/106665253/9270a8bd-d904-41d2-bb3e-abd3a21db71f)

Более сложным примером может служить код `8b/10b`, применяемый в оптических вариантах `Gigabit Ethernet`.

Биты входного блока обозначают как ABCDEFGH -- от младшего к старшему, выходного abcdefghij -- так же от младшего к старшему. Входной блок разбивается на два подблока: x из пяти битов и y из трех битов. Поэтому выходной код представляет собой конкатенацию двух кодов: `5b/6b` и `3b/4b`. Кроме собственно блоков данных D, имеются контрольные блоки K, которые кодируют альтернативно. 

Таким образом, входной блок обозначают как Dx.y либо Kx.y. Наконец, в код `8b/10b` заложена гибкая система уравнивания количества нулей и количества единиц, заключающаяся в динамическом выборе блока для замены (одного из двух) исходя из текущего значения так называемого `RD (Running Disparity)`. Предусмотрено два значение `RD`: -1 и +1. При выборе текущего значения `RD` учитывается предыдущее значение `RD` и соотношение нулей и единиц во входном блоке (плюс есть исключения).

![Selection_029](https://github.com/octolera/OKS/assets/106665253/4ed113cc-1ca1-464b-8a17-89eaebb97c6a)

![Selection_030](https://github.com/octolera/OKS/assets/106665253/e6aca55b-c4d9-407c-a286-64094f612917)

## 27. Поля Галуа и их применение в компьютерных сетях
https://habr.com/ru/articles/212095/

В теории помехоустойчивого кодирования очень важное место занимают
поля Галуа, но чтобы к ним «подойти» нужно сделать ряд шагов.

Некоторую операцию * называют бинарной если после ее применения к
двум любым элементам a и b некоторого множества получают элемент c,
принадлежащий тому же множеству: a * b = c.
А соответствующее непустое множество S называют замкнутым
относительно бинарной операции *.
Элемент e множества называют нейтральным если, после бинарной
операции над этим элементом и некоторым другим, другой участвовавший в
операции элемент не изменяется: a * e = a.
Два элемента множества называют обратными (относительно друг друга)
если в результате бинарной операции над ними получают нейтральный
элемент: a * b = e.

Множество G называют группой если для него определена бинарная
операция * и:
1. Операция * является ассоциативной: (a * b) * c = a * (b * c) --
соответствует умножению.
2. Существует нейтральный элемент -- соответствует единице.
3. Имеется унарная операция, позволяющая получить обратный элементу
a элемент -- соответствует a-1.

Группу называют абелевой если операция * коммутативна: a * b = b * a.
Если для группы определена операция умножения (a * b = ab), то группу
называют мультипликативной.
Мультипликативную группу называют циклической если в ней существует
такой элемент, что все остальные элементы являются степенями этого
элемента: b = ak. А сам элемент a называют образующим группу.

Классом вычетов по модулю n, принадлежащему множеству натуральных
чисел N, называют подмножество элементов из множества целых чисел Z,
имеющих одинаковый остаток от деления на n.
[a] -- класс вычетов, одним из элементов которого является a.
Группу, образованную множеством классов вычетов по модулю n,
называют группой классов вычетов по модулю n.

Группу называют конечной если группа состоит из конечного числа
элементов.
Число элементов |G| конечной группы называют ее порядком.

Два целых числа сравнимы (эквивалентно равны) по модулю
натурального числа n если при делении на n они дают одинаковые остатки: a
≡ b (mod n).

Отображение f: G -> H группы G в группу H называют гомоморфным если
оно сохраняет операцию группы G. Отображение изоморфно если оно
взаимно однозначно.
Отображение f: G -> G называют эпиморфным, изоморфное отображение
f: G -> G называют автоморфным.

Множество R называют кольцом если для множества определены две
бинарные операции # и * такие что:
1. Множество R является абелевой группой относительно операции # --
соответствует сложению.
2. Операция * является ассоциативной.
3. Выполняется закон дистрибутивности: a * (b # c) = a * b # a * c.
Если для группы определена операция сложения (a # b = a + b), то группу
называют аддитивной. Единичный элемент аддитивной группы соответствует
нулю. Обратный элементу a элемент аддитивной группы соответствует -a.
На операцию * можно накладывать дополнительные ограничения. Если в
кольце присутствует единица, то кольцо называют кольцом с единицей.
При выполнении закона коммутативности кольцо называют коммутативным.
Коммутативное кольцо называют целостным если его единица не равна
нулю и a * b = 0 только при a = 0 или b = 0

Кольцо называют телом если кроме нуля в кольце существуют другие
элементы и эти элементы образуют группу относительно операции *.
Наконец, коммутативное тело F называют полем.
Подгруппой, подкольцом, подполем называют подмножества сохраняющие соответствующие свойства.
Поле, не содержащее подполей, называют простым. Простым будет
поле, порядок которого равен простому числу.

Подкольцо I кольца R называют его идеалом (двухсторонним идеалом)
если для любой пары элементов a из I и r из R их произведение принадлежит
I.
Подкольцо R/I классов вычетов по модулю идеала I из кольца R называют
факторкольцом кольца R по идеалу I.
Наименьшее из натуральных чисел n, такое что для любого элемента r из
кольца R выполняется равенство n * r = 0, называют характеристикой
кольца R.

Согласно теореме, каждое конечное целостное кольцо образует поле.
Согласно другой теореме, характеристикой конечного поля является
простое число.
Поле GF(p) из целых чисел 0, 1 ... p - 1, порожденное в результате
отображения f: Z/p -> GF(p), где Z/p -- факторкольцо множества целых чисел,
в котором роль идеала играет простое число p, и f([a]) = a, называют полем
Галуа (Galois field) порядка p.
При вычислениях с элементами поля Галуа используют целочисленную
арифметику с приведением по соответствующему модулю.

дно и то же число можно записать самыми разными способами. Число
можно рассматривать и как значение полинома.
Полиномом (многочленом) одной переменной называют выражение:
n
f(x) = ∑aixi = anxn + an-1xn-1 + ... + a0 .
i=0
В случае полинома над кольцом, коэффициенты ai соответствуют
элементам кольца, а переменная x кольцу не принадлежит.
Два полинома f(x) и g(x) называют равными если равны их степени и
равны коэффициенты при одинаковых степенях переменной.
Если старший коэффициент полинома равен единице, то полином
называют приведенным.

Тривиальными делителями полинома называют сам полином и полином
равный 1.
Полином над полем F называют неприводимым над этим полем если
полином допускает только тривиальное разложение, то есть у полинома нет
нетривиальных делителей из F (с точностью до домножения на ненулевую
константу).

Для практического применения полей Галуа в компьютерных системах необходимо перейти от скалярного представления к векторному.
Расширенное поле Галуа GF(pn) можно рассматривать как векторное пространство, где простое число p является характеристикой поля и соответствует количеству состояний разряда вектора, а n является степенью поля над его простым подполем и соответствует количеству разрядов вектора.
Поскольку в обычных компьютерных системах разряды регистров бинарные, то наибольший интерес представляют поля GF(2n).

Сложение бинарных векторов (совпадает с вычитанием) проблему не представляет и соответствует поразрядной операции xor. А вот с умножением и делением дела обстоят значительно сложнее. Скалярное произведение не подходит, так как его результат может «выйти» за пределы поля. Векторное произведение определено только для трехразрядных векторов.
Полиномиальное представление так же с ходу не решает проблему, так как произведение полиномов опять же «выводит» за пределы поля. Для обеспечения конечности поля Галуа, полученный в результате произведения полином нужно привести. Это достигают путем деления на некий выбранный полином степени n. Ясно, что выбирать можно разные полиномы. Выбор другого полинома приведет к другим результатам умножения и, соответственно, к другому полю GF(pn).

**Выбранный для построения поля Галуа полином называют порождающим (образующим)**

Деление векторов в математике не известно.
После перехода на язык полиномов, опять же для обеспечения конечности поля Галуа, деление всегда должно быть безостаточным. Деление можно представить как умножение полинома-делимого на полином, обратный делителю. При этом для достижения цели на основании математических выкладок, необходимо ввести еще одно ограничение: порождающий полином
должен быть неприводимым по модулю p (например, если p = 2 и n = 4, то полином x4 + 1 (число 17) не подходит, так как x4 + 1 ≡ (x2 + 1)2 (mod 2) ).

**Возведение в степень обладает цикличностью**.

## 28. Модель помехоустойчивого канала связи и теорема Шеннона
Считается, что начало помехоустойчивому кодированию положила **теорема Шеннона**, утверждающая что любой дискретный канал связи имеет конечную пропускную способность и этот канал может быть задействован для передачи информации со сколь угодно большой степенью достоверности, не смотря на наличие помех.

![Selection_031](https://github.com/octolera/OKS/assets/106665253/980bb9cd-fff8-48c5-95aa-d54f60185c15)
Передаваемое сообщение разбивается на блоки фиксированного размера
a из k битов a1, a2 ... ak.
Кодер выполняет функцию f, называемую схемой кодирования, и тем
самым преобразует вектор а в вектор c из n > k битов c1, c2 ... cn, называемый
кодовым словом.
В процессе пересылки кодового слова по каналу связи на него
накладывается вектор ошибок e, в котором единичные биты соответствуют
искажениям.
После применения декодером схемы декодирования g получается вектор
a', в идеале совпадающий с исходным вектором a.

Подобная схема кодирования является избыточной. На практике всегда
ищут компромисс между степенью обеспечения достоверности при передаче
и вычислительной сложностью кодов (что в первую очередь отражается на
скорости декодирования).
В КС множество кодовых слов получается из множества исходных слов
как отображение из конечного поля GF(2k) в конечное поле GF(2n).
При более простых схемах кодирования, в кодовом слове сначала
располагаются биты входного сообщения, называемые информационными, а
за ними дополнительные биты, называемые проверочными: a1, a2 ... ak, ck+1,
ck+2 ... cn.
В более сложных случаях проверочные биты чередуются с
информационными.

## 29. Линейные помехоустойчивые коды, включая коды Хэмминга и циклические коды
Схему кодирования удобно представлять в матричном виде.

![Selection_031](https://github.com/octolera/OKS/assets/106665253/1e39cfc2-be01-4e60-bdf2-c7c57ee9f256)

Видно, что проверочные уравнения образуют систему линейных
уравнений. Следовательно, отображение f (схема кодирования) является
**линейным**.

Если H -- матрица размером (n - k) × n ранга n - k и H cT = 0, то множество
всех n-разрядных векторов, входящих в поле GF(2n) (в общем случае GF(pn)),
называют линейным (n,k)-кодом (в математическом смысле) длины n и
размерности k. А матрицу H называют проверочной.
Линейный код по-другому называют групповым, так как множество
кодовых слов можно рассматривать как подгруппу в отношении поля GF(2n).
Линейный код называют систематическим (разделенным) если
расположение проверочных битов известно (не важно где они находятся), то
есть если H = [A In - k], где A -- матрица размером (n - k) × k, а In - k --
единичная матрица ранга n - k.
Матрицу G = [Ik-AT] размером k × n называют кодирующей
(порождающей) матрицей систематического кода.
Кодирующая и проверочная матрицы связаны следующим образом:
GHT = 0.

Перед выбором того либо иного помехоустойчивого кода всегда нужно
определиться, что требуется от кода. Если перефразировать, то нужно
ответить на два вопроса:
1. Сколько бинарных ошибок код должен обнаруживать.
2. Сколько бинарных ошибок код должен исправлять.
Исправлять ошибки значительно сложнее, чем обнаруживать.
Применительно ко многим кодам, исправление ошибки подразумевает
нахождение ее позиции.

```
В общем случае ошибки носят случайный характер. Множественные
ошибки могут быть взаимозависимыми, то есть образовывать модули ошибок.
Если ошибки расположены рядом, то они образуют пакет ошибок (частный
случай модуля).
```
### Бинарным кодом Хэмминга
называют код длины n = 2m - 1, m ≥2 с
проверочной матрицей H размером m × (2m - 1), в которой столбцы
соответствуют записи 1, 2 ... 2m - 1 в двоичной системе счисления.
Код Хэмминга позволяет исправлять одиночную ошибку и обнаруживать
множественные ошибки.

Число координат (позиций), которыми два вектора x и y различаются
называют **расстоянием Хэмминга** -- `d(x,y)`.
Число ненулевых позиций вектора x называют **весом Хэмминга** -- `w(x)`.
Видно, что **расстояние Хэмминга** показывает количество возникших
ошибок.

### Циклические коды являются особо выделяемой подгруппой линейных кодов.
Циклическим кодом называют линейный код, удовлетворяющий
дополнительному условию: если вектор a0, a1 ... an-1 является кодовым
словом, то и его циклический сдвиг an-1, a0 ... an-2 так же является кодовым
словом.
Циклический код позволяет исправлять одну и более ошибок и
обнаруживать множественные ошибки (зависит от параметров).

Базовая идея **циклического кодирования** состоит в том, чтобы в качестве
проверочных битов передавать остаток от деления информационных битов
на некоторое выбранное число.
После приема снова выполняется деление уже возможно искаженных
информационных битов на то же самое число и сравниваются остатки.
Если остатки совпадают, то данные с определенной вероятностью
приняты без ошибок.

На практике же деление выполняется **по правилам арифметики полей
Галуа**, то есть без учета переносов.
Информационные биты, то есть делимое, соответствуют
информационному полиному.
Делитель соответствует **порождающему (образующему) полиному**.
Частное в процессе кодирования не используется и поэтому
«отбрасывается».

Для того чтобы максимально разнообразить остатки в качестве
порождающего полинома должен выбираться **неприводимый полином**.

Существуют два подхода к реализации циклического кода на стороне
приемника:
1. Согласно базовой идее, описанной выше.
2. На порождающий полином делится все принятое кодовое слово. Если
ошибок не произошло, то остаток будет нулевым.

Оба подхода равноценны.

## 30. Классификация помехоустойчивых кодов
За достаточно длительную историю развития прикладной теории
кодирования, как науки, было придумано очень много помехоустойчивых
кодов.

Основные группы помехоустойчивых кодов:
1. Линейные коды, в том числе: коды Хэмминга, циклические коды, БЧХ-
коды (коды Боуза-Чоудхури-Хоквингема), РМ-коды (коды Рида-Маллера),
итеративные коды, коды на основе матриц Адамара, симплексные коды и
некоторые другие.
2. Коды для контроля модульных и пакетных ошибок, в том числе: РС-
коды (коды Рида-Соломона), низкоплотные модульные коды, векторные
модульные коды, итеративные модульные коды и некоторые другие.
3. Сверточные коды.
4. Арифметические коды.
5. Низкоскоростные коды, в том числе: коды максимальной длины,
нелинейные коды, D-коды и некоторые другие.

## 31. Классификация каналов в сети передачи данных
На физическом уровне оперируют с сигналами, поэтому концентрируются
на отдельно взятом передатчике, отдельно взятом приемнике и
последовательном канале, который их связывает. Для обеспечения
модуляции этого вполне достаточно. **При этом приемник активен всегда, а
передатчик включается по мере надобности**.

С точки зрения направленности, последовательный канал может
функционировать в одном из трех режимов:

1. Симплексном (simplex) -- передача данных по каналу возможна только
в одном направлении.
2. Полудуплексном (semiduplex) -- данные могут передаваться в обоих
направлениях, но в один момент времени возможна передача только в одном
направлении.
3. Полнодуплексном (full duplex) -- данные могут передаваться в обоих
направлениях одновременно.

Сейчас в КС доминируют полнодуплексные каналы

Топология «возникает» на канальном уровне, когда речь идет об
организации сегмента.

Последовательный канал может быть:
1. `Выделенным (leased)` -- зарезервирован за определенной парой
станций-абонентов.
2. `Разделяемым (shared)` -- может использоваться несколькими
станциями-абонентами.

Причем канал, который не может разделяться несколькими станциями-
передатчиками одновременно, в отечественной литературе принято называть
моноканалом. Во многих реализациях ситуация именно такая.

С точки зрения общей организации процесса пересылки данных, все СПД
можно разделить на два фундаментальных типа:

1. `СПД с коммутацией пакетов (packet-switched)` -- в структуру пакетов
включают адреса станций-абонентов; каждое устройство-посредник
определяет дальнейший путь на основании анализа адресов назначения;
каждый из пакетов в цепочке пересылается независимо от остальных
(следует учитывать, что в сложных СПД имеются альтернативные пути
пересылки).
2. `СПД с коммутацией каналов (circuit-switched)` -- адреса станций-
абонентов в структуру пакетов (кадров) не включают; сначала, по запросу
станции-передатчика, на основании запрашиваемого адреса, СПД
«прокладывает» к вызываемой станции канал, называемый коммутируемым;
каналы-звенья могут быть как выбранными «целиком» каналами (как правило
между оконечными устройствами и устройствами-посредниками), так и
выбранными подканалами каналов с частотным или временны'м
разделением (как правило между устройствами-посредниками); затем
созданный канал используется для пересылки пакетов (кадров).

## 32. Логические и физические топологии LAN
режде всего, топологии делят на два типа:
1. `Point-to-point` -- топология «точка к точке» -- связывает только две
станции.
2. `Multi-access (multipoint-to-multipoint)` -- топология с множественным
доступом -- связывает более двух станций.
Эти два типа позволяют организовывать двунаправленные каналы между
любым требующимся количеством абонентов, поэтому их реализуют
наиболее часто.
Применительно к однонаправленным каналам можно добавить еще два
пункта:

+3. `Point-to-multipoint` -- иногда.

+4. `Multipoint-to-point` -- очень редко.

Менее двух станций в сегменте быть не может.

В общем случае, направленность каналов может «накладываться» на
топологии по-разному. Например, кольцо может быть однонаправленным и
двунаправленным.
Сегмент может иметь и `гибридную топологию (hybrid topology)`.

Если
топологически
классифицировать
аппаратные
технологии
(охватывающие два нижних уровня модели OSI), то есть еще два ракурса:
1. `Физическая топопогия (physical topology)` -- отражает физические связи
между устройствами.
2. `Логическая топопология (logical topology)` -- отражает логические связи
между устройствами.

Часто логическая топология не совпадает с физической.

Характерными топологиями ЛКС являются:
1. `Шина (bus)`.
2. `Кольцо (ring)`.
+3. `Звезда (star)`.

```
Сегменты соединяют произвольным образом, поэтому на сетевом уровне
уместно говорить о топологии с произвольными связями, хотя топологию в
отношении третьего уровня упоминают весьма редко.
Протоколы сетевого уровня обычно разрабатывают топологически
независимыми.

Начиная с транспортного уровня, топологии применимы к связям между
программами, производящими и потребляющими сетевые услуги, поэтому
могут быть только логическими.
Здесь характерными топологиями являются:
1. Point-to-point -- при двунаправленной передаче.
2. Point-to-multipoint -- при однонаправленной передаче.
```

## 33. Логические и физические топологии WAN и RAS
Характерными топологиями `ГКС` являются:
- 1. `Сеть (произвольно связанная) (mesh)`.
- +2. `Ступица со спицами (hub-and-spoke)`.
- +3. `Полносвязная сеть (full-mesh)`.
- 
Характерной `RAS`-топологией является `point-to-point`.
Можно сказать, что для `ГКС`-технологий существует только одна типичная
топология (произвольно связанная сеть), остальные можно рассматривать как
ее частные случаи.

Для `RAS`-технологий существует только одна типичная топология.
На начальных этапах изучения, Cisco не отделяет RAS от ГКС.

## 34. Особенности случайных методов доступа к моноканалу
## 35. CSMA/CD (Ethernet)
## 36. Кадр Ethernet
## 37. CSMA/CA (Wi-Fi)
## 38. Кадры Wi-Fi
## 39. Особенности детерминированных методов доступа к моноканалу
## 40. Алгоритм Token Ring
## 41. Реализации детерминированных методов доступа к моноканалу
## 42. Адресация в компьютерных сетях и классификация адресов
## 43. MAC-адреса
## 44. Заголовок IPv4
## 45. Заголовок IPv6
## 46. Протокол ARP
## 47. Структура системы DNS
## 48. Сообщения DNS
## 49. Виртуальные соединения в сети передачи данных
## 50. Классификация оконных механизмов, используемых в сети передачи данных
## 51. Структура системы TCP
## 52. Заголовок TCP
## 53. Протокол TCP
## 54. Усовершенствования протокола TCP
## 55. Протокол UDP и заголовок UDP
## 56. Классификация и характеристики сред передачи данных
## 57. Среды передачи данных на основе коаксиальных кабелей
## 58. Среды передачи данных на основе витых пар
## 59. Среды передачи данных на основе оптоволоконных кабелей
## 60. Физический уровень Ethernet
## 61. Структурированные кабельные системы и их модели
## 62. Питание и заземление в структурированных кабельных системах
## 63. Пожарная безопасность структурированных кабельных систем
## 64. Технология PoE
# Практические (задания) 
## 65. Структура системы FTP
## 66. Протокол FTP и режимы обмена по протоколу FTP
## 67. Структура и особенности системы Telnet
## 68. Электронные письма и почтовые ящики
## 69. Обобщенная структура системы электронной почты
## 70. Почтовые агенты
## 71. Протокол SMTP и его расширения
## 72. Протокол POP3 и его расширения
## 73. Протокол IMAP и его расширения
## 74. Структура системы HTTP
## 75. Ресурсы в системе HTTP
## 76. Заголовки HTTP
