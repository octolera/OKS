# Теоретические билеты
```
Переписать!
Поля Голуа, Token ring
```
## 1. Понятие компьютерной сети
Компьютерная сеть - совокупность компьютеров и прочего оборудования(периферия, маршрутизаторы  и т.д.), предназначенная для передачи компьютерной информации на относительно большие расстояния за пределами самих компьютеров

Любая КС может быть рассмотрена как совокупность программной и аппаратной части.

В основе любой КС лежит сеть передачи данных (СПД) — т.е сеть передачи данных (Data Communication Network), которая задействует различные среды передачи данных (СрПД).
Иногда в составе СПД выделяют базовую (опорную) СПД.

Все устройства в составе СПД можно разделить на:
- **End devices - периметр СПД**  (персональный компьютер, ноутбук, смартфон, планшет, принтер, сервер, роутер домашней сети, IP-телефон)
- **intermediary devices - “ядро” СПД**  (роутер, коммутатор (switch), маршрутизатор (router), брандмауэр (firewall), модем, многопортовый повторитель (hub), устройство балансировки нагрузки (load balancer), прокси-сервер)

![Selection_003](https://github.com/octolera/OKS/assets/106665253/d4665785-7019-4800-a966-3c4e7855e020)

Трафик в СПД разделяют на 
- обычные компьютерные данные - data
- голос - voice
- видео - video

В нотации Cisco сети способные посылать разнородный трафик называют конвергированными (converged networks)

Особенности трафика обеспечиваются качеством обслуживания **Quality of Service (QoS)**.
Традиционные данные обслуживаются по модели best efforts - все делается для доставки пакетов, но при этом ничего не гарантируется, т.е. фактически QoS отсутствует.
QoS присутствует при работе с голосом и видео

В рамках предоставляемой оборудованием СПД **полосы пропускания (bandwith)** можно выделить:
- throughput - реально задействованная часть
- goodput - полезная составляющая throughput без учета служебного трафика

## 2. Классификация компьютерных сетей
Среди КС выделяют:

- Local Area Networks (LANs) -- локальные КС (ЛКС). `Выделяют прежде всего территориально -- в современном понимании, охватывает территорию не более кампуса, но при этом подразумевают определенные технологии`
- Wide Area Networks (WANs) -- глобальные КС (ГКС). `Выделяют прежде всего технологически и, в общем случае, может охватывать произвольную территорию`
- Metropolian Area Networks (MANs) -- городские КС (устоявшейся русскоязычной аббревиатуры нет). `Представляет собой промежуточный вариант между LAN и WAN`
- Personal Area Networks (PANs) -- личные КС (устоявшейся
аббревиатуры нет). `Позволяет подключить к компьютеру периферийные устройства`
- Remote Access Services (RASes) -- КС для подключения удаленных пользователей (teleworkers) (так же устоявшейся аббревиатуры нет). `RAS существует в контексте WAN`
- Industrial Networks -- промышленные КС.
- Datacenter Networks -- КС центров обработки данных.
    
    `Industrial и Datacenter Networks являются специализированными
    вариантами LAN`
    

Также выделяют:

- Intranets - внутреннние КС организаций и предприятий. `Обычно выделяют по ведомственной принадлежности пользователей.`
- Internets - КС публичного доступа. `Практически все Internets сейчас интегрированы в одну сборную
одноименную сеть.`

`Intranet почти всегда имеет связь с Internet`

Сети могут быть:
- isolated (изолированными)
- open (открытыми для прослушивания)

С точки зрения организации сети могут быть:
- сильносвязанными
- слабосвязанными

**Сильносвязанная** КС предполагает наличие наличие **хост-ЭВМ (host)** с одной стороны и **терминала (terminal)** -- с другой. Хост является основным вычислительным компонентом. Под терминалами подразумевают исключительно устройства для ввода и отображения информации, следовательно, они без хоста бесполезны. 

Совокупность хоста и подключенных к нему терминалов принято называть **рабочей станцией (workstation)**. 
Терминал администратора, обычно подключаемый особым образом, называют **консолью (console)**.

`Мы имеем дело с хост-терминальной моделью`

**Слабосвязанная** КС предполагает наличие **сервера (server)** с одной стороны и **клиента (client)** -- с другой.

Клиентские ЭВМ, обслуживающие запросы пользователей, являются **активными компонентами**.

Сервер либо серверы, являющиеся пассивными компонентами, в свою
очередь, обслуживают запросы клиентов. Как клиенты, так и серверы могут работать независимо, связываясь по
мере надобности.

`Мы имеем дело с клиент-серверной моделью`

Технически не входит в состав билета, но было в материале:
```
С точки зрения общей организации работы сетевых устройств, в первую очередь касательно WANs и RASes, принято
выделять два типа оборудования:
  1. Оконечное оборудование данных (ООД) -- Data Terminal Equipment (DTE).
  2. Аппаратура передачи данных (АПД) -- Data Communication Equipment или, по-другому, Data Circuit-terminating
Equipment (DCE).

Термины происходят из традиционной телефонии.

ООД находится на самой границе СПД и «концентрирует», то есть создает и потребляет передаваемые информационные
потоки.
АПД находится в пределах СПД и «транслирует», то есть позволяет передавать и принимать информационные потоки.
Разница заключается и в синхронизации передаваемых потоков.
Первоисточником синхронизации обычно является АПД.
Понятие ООД хорошо соотносится с понятием оконечных устройств, а понятие АПД хорошо соотносится с понятием устройств-
посредников. Но, поскольку, термины ООД и АПД связаны с определенными технологиями, а задействующие эти технологии
устройства часто встречаются в самых разных частях СПД, знаки равенства ставить некорректно.
```

## 3. Стандарты компьютерных сетей
Все стандарты, в том числе в области КС, делят на:
 - Международные (например, ISO/IEC).
 - Европейские (например, EN).
   - Американские (например, ANSI/TIA/EIA).
Стандарты лишь формализуют определенные требования в той или иной предметной области.

Стандарты могут носить **предварительный (preliminary)** или **временный (interim)** характер. Могут включать **дополнения (annexes, addendums = addenda)** и **списки обнаруженных ошибок (errata)**. Могут **устаревать или замещаться другими стандартами (obsolete)**.

**Практическим (или теоретическим) воплощением** стандарта является так называемая **реализация (implementation)**.

**Сертификация (certification)** позволяет определить факт соответствия стандарту.
В 1980 г. при IEEE был создан специальный комитет по стандартизации КС, результатом работы которого стало множество стандартов `802.x`

Сейчас наибольший интерес представляют:
- `802.3` -- Ethernet.
- `802.11` -- Wi-Fi.
- `802.16` -- WiMax.
  
Стандарты Ethernet по пропускной способности делят на три группы:
- Ethernet -- до 10 Mbit/s включительно.
- Fast Ethernet -- 100 Mbit/s.
- Gigabit Ethernet -- 1, 10, 100, 40, 25 Gbit/s и Multigigabit.

Повсеместное внедрение ЛКС привело к необходимости их интеграции в инфраструктуру зданий и сооружений.

**Структурированная кабельная система (СКС) -- Structured Cabling System (SCS)** -- представляет собой упорядоченную гетерогенную коммуникационную подсистему зданий и сооружений.

Выделяют следующие стадии работ, связанных с СКС, для каждой из которых предусмотрен собственный набор стандартов:
- Проектирование.
- Монтаж.
- Эксплуатация.
  
## 4. Наиболее распространенные модели компьютерных сетей
Из всех моделей КС основной является **открытая модель взаимодействия систем - Open System Interconnection (OSI)**, разработана ISO.

Модель включает в себя 7 уровней:

![Selection_004](https://github.com/octolera/OKS/assets/106665253/2b0ec63f-345d-470d-8dae-1b9f1a4c042a)

`На вершине иерархии находится человек.`
`Абонентами КС являются взаимодействующие программы`

## 5. Физический уровень модели OSI
На физическом уровне формализуют подключение сетевого устройства к СрПД. **Соответственно в пространстве физический уровень охватывает «точку» подключения.**
Специфическими понятиями физического уровня являются:
- среда;
- разъем (физический порт);
- несущая (частота);
- модуляция;
- сигнал.

Фундаментальная задача физического уровня заключается в **передаче сигнала**.

## 6. Канальный уровень модели OSI
На канальном уровне (datalink) формализуется **взаимодействие станций в пределе сегмента**.

**Станция или узел (node)** - любое устройство, способное передавать или принимать сетевой трафик - пк, сервер, маршрутизатор и т.д.
Физически любая КС состоит из **сегментов** - множества станций обьединенных посредством одной СрПД и "видящих" друг друга непосредственно. Технологическая реализация сегментов может отличаться.

В традиционном понимании СрПД соответствует **физическому соединению (link)**. Однако многие современные технологии предполагают наличие в СрПД "прозрачных" устройств- посредников (преобразователей и коммутаторов).

Специфическими понятиями канального уровня являются:
- сегмент сети
- физическая и логическая топология сегмента
- пакет (кадр)
- бит- и байт-стаффинг
- адресация в пределах сегмента
- канальный код
- код проверки целостности пакета (кадра)
- алгоритм доступа к моноканалу

Каждый из уровней модели OSI может быть реализован достаточно сложно, но канальный уровень особенно сложен. Поэтому его разделяют на два подуровня:
- **MAC (Media Access Control)** -- контроль доступа к СрПД.
- **LLC (Logical Link Control)** -- контроль логического соединения.

**На подуровне MAC, более низком,** выполняется взаимодействие с физическим уровнем, то есть средозависимые операции, такие как формирование и распознавание пакетов, адресация, канальное кодирование и другие.

**На подуровне LLC, более высоком,** выполняется взаимодействие с сетевым уровнем, то есть средонезависимые операции, такие как разбиение данных на пакеты, сборка данных из пакетов, определение соответствующей подсистемы сетевого уровня и другие.
  
## 7. Сетевой уровень модели OSI
`Сетевой уровень позволяет «выйти» за пределы сегмента.`

### На сетевом (network) 
уровне формализуют построение полноценной КС произвольного масштаба, охватывающей произвольное количество сегментов.

Специфическими понятиями сетевого уровня являются:
- пакет (собственно пакет)
- адресация в пределах всей КС
- маршрутизация.

## 8. Транспортный и сеансовый уровни модели OSI
**Транспортный уровень** позволяет перейти от оборудования к программам. На **транспортном (transport)** уровне формализуют использование программным обеспечением сетевого оборудования, то есть как отдельно взятым программам предоставляется «транспорт».

Специфическими понятиями транспортного уровня являются:
- пакет (сегмент сообщения)
- программный порт
- логическое соединение
- надежность доставки
- алгоритм борьбы с заторами в СПД.

### Сеансовый или сессионный (session) 
уровень позволяет предоставить доступ к транспорту всем программам в многозадачном окружении.

Кроме собственно сессии, имеются еще два основных специфических понятия сеансового уровня:
- программный порт
- алгоритм мультиплексирования программ.

В практических реализациях сеансовый уровень выражен слабо и обычно совмещается с транспортным.

## 9. Прикладной уровень и уровень представления модели OSI
### Прикладной (application)
уровень призван решать конкретные пользовательские задачи с помощью КС.

Примерами прикладных задач могут служить:
- пересылка файлов между компьютерами
- пересылка электронных писем
- поддержка удаленных текстовых и графических терминалов, в том числе для администрирования
- пересылка мультимедийных документов
- обмен «мгновенными» сообщениями
- совместная разработка чего-либо
и другие.

Плюс, выделяемые особо, как несвойственные традиционным компьютерным сетям, задачи пересылки голоса и видео в реальном времени. `При этом, QoS «возникает» и на всех нижестоящих уровнях`. 

Специфических понятий прикладного уровня великое множество и они зависят от решаемых задач.

### Уровень представления (presentation) 
позволяет адаптировать прикладную информацию в форму, приемлемую для передачи по КС, то есть является прослойкой между программами и транспортом

Основными задачами уровня представления являются:
- кодирование информации (включая возможное сжатие) с целью обеспечения ее правильной интерпретации в последующем;\
- шифрование информации с целью обеспечения ее защиты при пересылке по открытым для прослушивания сетям
  
`Поскольку обычно уровень представления «привязан» к прикладному уровню, в реализациях эти уровни часто совмещаются`.

Взаимодействие в рамках модели OSI может быть «вертикальным» и «горизонтальным»:
- **Интерфейс (interface)** -- это правила взаимодействия между пространственно совмещенными соседними уровнями модели OSI.
- **Протокол (protocol)** -- правила взаимодействия между пространственно разнесенными одинаковыми уровнями модели OSI.
И в том, и в другом случае предполагают определенную абстракцию.

## 10. Семейство протоколов TCP/IP
Исторически сложились два основных семейства протоколов:
- TCP/IP.
- IPX/SPX.

В настоящее время TCP/IP полностью доминирует. IPX/SPX почти не используют

![Selection_005](https://github.com/octolera/OKS/assets/106665253/a0cb5c54-5837-480d-b881-6a9a4413f466)

`Семейство протоколов TCP/IP описано в стандартах RFC (Request For
Comments)`.

С семейством протоколов TCP/IP связана одноименная модель. Cопоставление с моделью OSI:

![Selection_006](https://github.com/octolera/OKS/assets/106665253/335c673f-8fca-4df3-94bf-e33c3cbd7a47)

## 11. Эволюция COM-портов и их место в современных устройствах
История развития **последовательного (serial)** или, по-другому, **коммуникационного (COMmunication)** порта неразрывно связана с развитием элементной базы.

Применительно к ПК разработчиком как базовой архитектуры так и типовых схем оборудования являлась и до сих пор является компания Intel.

В развитии COM-порта ПК можно выделить следующие основные этапы (следует отметить, что этот процесс сильно коррелирует с развитием COM-портов всех типов компьютерных систем):

- В свое время (семидесятые годы XX века), в составе периферийной части комплекта микросхем поддержки микропроцессора 8080, компания Intel разработала два контроллера последовательного порта. Один из них, `8250`, получил название `UART (Universal Asynchronous Receiver/Transmitter)` - универсальный асинхронный приемник-передатчик.

- Второй, `8251`, получил название `USART (Universal Synchronous/Asynchronous Receiver/Transmitter)` - универсальный синхронно-асинхронный приемник-передатчик.

Эти контроллеры были рассчитаны на подключение по шине X-Bus (шина ввода-вывода, внутрисхемный восьмибитный предшественник системной шины ISA) и поэтому без труда были перенесены в первые ПК на базе процессора 8086 и его модификаций (то есть компьютеры класса IBM PC XT) с тогда наиболее распространенной системной шиной ISA.

Совместно с контроллером параллельного порта `8255`, микросхема `UART` либо `USART` устанавливалась на плату специального адаптера и подключались к материнской плате ПК посредством разъема системной шины.

В это же время возникла традиция устанавливать последовательные порты парами (COM1 и COM2).

### Времена доминирования процессоров 80286 -- Intel486 (то есть компьютеры класса IBM PC AT и IBM PS/2) ознаменованы постепенно набравшими силу интеграционными процессами.

На первом этапе происходило распространение и развитие самих контроллеров.

В СССР был создан аналог 8251 под названием `КР580ВВ51А`, который и стал массово применяться в серии ЕС ПК.

На Западе же, наоборот, развитие получила микросхема `8250`.

Апофеозом достаточно быстрого усовершенствования `8250` стали несколько UART, среди которых следует выделить `16550`, причем это была разработка уже не Intel, а National Semiconductor. Именно эта микросхема стала де факто стандартной на длительное время (архитектурная совместимость сохраняется вплоть до настоящего времени). `16550` имеет два основных преимущества перед `8250`: 
- более высокая пропускная способность последовательного интерфейса (максимальная стандартная пропускная способность увеличена с 9600 baud до 115200 baud)
- возможность буферизации (две очереди FIFO по 16 байт -- на стороне передатчика и на стороне приемника).

В дальнейшем интеграционные процессы привели к появлению так называемых `мультикарт` -- подключаемых посредством разъема системной шины (по-прежнему обычно ISA) плат расширения с интегрированными контроллерами: последовательного порта (2x16550), параллельного порта, игрового порта, НГМД и НЖМД. Причем все **эти функции сочетались в одной
БИС с типичным названием Multi I/O**. 

Основными производителями чипов Multi I/O были компании Winbond, UMC, GoldStar и другие.

`Для ПК на базе поздних Intel486 уже была характерна интеграция чипа Multi I/O на материнскую плату`.

### Во времена процессоров Pentium сформировалась действительная до сих пор базовая крупноблочная структура материнской платы ПК, состоящая из четырех основных БИС

![Selection_007](https://github.com/octolera/OKS/assets/106665253/bdd163c2-4ef4-4fc7-a0fa-782ada44a671)

Контроллеры последовательного порта (по той же схеме 2x16550) в составе интегрированной периферии были перенесены и в эту структуру.

После перехода от `мостовой (bridges)` организации ПК к `хабовой (hubs)` в рамках данной структуры (начиная с восьмисотой серии чипсетов Intel в эпоху Pentium III) `для внутрисхемного подключения Super I/O вместо шины X-Bus
стала использоваться шина LPC (Low Pin Count)` -- специализированная разновидность шины PCI с небольшим числом разрядов.

```
В настоящее время (приблизительно с 2005 года) традиционный последовательный интерфейс ПК считают устаревшим (legacy), часто исключают из состава интегрированной периферии -- на материнских платах можно увидеть все реже.

Сейчас в качестве основного последовательного интерфейса ПК
рассматривают шину USB (Universal Serial Bus), впервые введенную в состав
ПК еще в эпоху процессоров Pentium.
```
## 12. Структура COM-порта
Сам факт передачи информации подразумевает наличие передатчика, приемника и канала, по которому они связаны. Как и следует из названия, UART 16550 сочетает в себе функции как приемника, так и передатчика. 

Предоставлена возможность подключения к двунаправленному каналу связи в соответствии со стандартом RS-232. На аппаратном уровне приемник и передатчик работают **параллельно**, то есть **по отдельным физическим цепям полностью независимо друг от друга**.

Структурная схема UART 16550.

![Selection_008](https://github.com/octolera/OKS/assets/106665253/173ee55e-ed02-43b6-af1e-be508245a20b)

Интерфейс RS-232 (традиционное название, последнюю редакцию 1997 года правильно называть TIA-232-F, существуют и другие названия) предназначен для подключения АПД (например, модема) к ООД (например, UART).Для физического подключения по стандарту RS-232 используют девятиконтактные разъемы D Subminiature (D-sub) DE-9. В старых ПК класса IBM PC использовали и аналогичные двадцатипятиконтактные разъемы DB-25.

Принято, что штырьевую часть разъема устанавливают со стороны ООД, а гнездовую часть -- со стороны АПД.

Согласно PC System Design Guide, с 1999г. разьёмы последовательных портов окрашивают в бирюзовый цвет.

## 13. Цепи RS-232 и их использование
### Традиционное назначение цифровых цепей RS-232
- `SOUT` (Serial Output) -- выход передатчика;
- `SIN` (Serial Input) -- вход приемника;
- `RTS` (Request to Send) -- сигнал-запрос от UART к модему о передаче байта;
- `CTS` (Clear to Send) -- сигнал-подтверждение от модема к UART о готовности принять байт для передачи;
- `DSR` (Data Set Ready) -- сигнал от модема к UART о готовности к взаимодействию;
- `DTR` (Data Terminal Ready) -- сигнал от UART к модему о готовности к взаимодействию;
- `DCD` (Data Carrier Detect) -- сигнал от модема к UART об обнаружении данных;
- `RI` (Ring Indicator) -- сигнал от модема к UART об обнаружении входящего телефонного звонка.

Служебные цепи RS-232 позволяют организовать `контроль информационного потока (flow control)`. Например, это позволяет избегать переполнения приемника, приостанавливая «быстрый» передатчик. Следует отметить, что практически все служебные цепи напрямую связаны с соответствующими регистрами управления и состояния UART 16550, то есть «открыты» для программирования. Следовательно, алгоритмы контроля реализуют программно и закладывают, например, в драйверы операционных систем. Контроль может быть как полуаппаратным (с задействованием сигналов RS-232), так и сугубо программным. 

Очевидно, что традиционное использование пары `RTS/CTS` позволяет контролировать передачу только в одном направлении -- `от UART к модему`. Для контроля передачи `в обратном направлении` использовалась пара `DSR/DTR`.

В большинстве современных реализаций контроль по прежнему предполагает наличие обратной связи, но осуществляется только приемником. Два основных метода:
- `RTS/CTS` -- полуаппаратный.
- `XON/XOFF` -- программный.
UART контролирует передачу данных «к себе» управляя активностью цепи `RTS`, модем -- `CTS`.
Значительно реже применяют метод `DTR/DSR` -- полностью аналогичен  методу `RTS/CTS`, но значения сигналов сохраняются на протяжении всего информационного обмена, а не каждой посылки.

При полностью программном контроле, приемник передает в обратном направлении специальный байт `XON` (стандартное значение 11h) для инициирования передачи и специальный байт `XOFF` (стандартное значение 13h) для остановки передачи.

В стандартной ситуации, **ООД взаимодействуют между собой посредством АПД**, причем с помощью так называемых «рукопожатий» (handshaking) с АПД. При этом подключение АПД к ООД осуществляют `посредством «прямого» кабеля (straight-through cable)`.
Для подключения **двух ООД друг к другу** непосредственно необходим один из вариантов `нуль-модемного (null-modem, поскольку предполагают отсутствие модема) кросс-кабеля (crossover cable, поскольку цепи SIN и SOUT скрещивают)`.

`Для изготовления кросс-кабеля нужны минимум три провода.`

![Selection_009](https://github.com/octolera/OKS/assets/106665253/374159dc-c575-490a-b0bd-ccfce22d5ae0)

```
Иногда программное обеспечение рассчитано только на использование модемов. В подобных ситуациях, для непосредственного подключения двух ООД необходимо «закоротить» соответствующие пары сигналов.

Часто в литературе приводят еще одну схему нуль-модемного кабеля, в соответствии с которой роль модема играет ООД-абонент.

При этом нужно иметь в виду, что в информационных системах принято все «мерить» относительно человека, в том числе и ввод-вывод. Таким образом, в ПК направление определяется «с точки зрения» центрального процессора, а в данном случае -- «с точки зрения» ООД.
```
## 14. Асинхронный режим работы COM-порта
**Асинхронный (asynchronous)** -- синхронизируется посылка каждого информационного байта.

![Selection_010](https://github.com/octolera/OKS/assets/106665253/c27b2dd3-4eef-470c-ab41-da0329075f7a)

**Атомарной, то есть минимальной неделимой единицей**, с которой работает как UART, так и USART, является байт, причем один байт не обязательно равен восьми битам и может содержать от `5` до `8` битов. 

По умолчанию линия находится в состоянии логической единицы.
При наличии байта для передачи передатчик переводит линию в состояние логического нуля, то есть передает старт-бит, что говорит приемнику о том, что на следующем такте нужно «ловить» первый информационный бит.
`Стоп-бит` необходим для того, чтобы после передачи информационной последовательности гарантированно вернуть линию в исходное, то есть единичное состояние.
`Старт-бит` всегда **один**, а стоп-битов может быть **один, полтора либо два**.

Для проверки целостности информационной части, **если эта проверка включена**, за информационной частью вставляется `бит паритета`. При этом действует правило дополнения. Например, если включена проверка единиц на четность (even), то бит паритета формируется таким образом, чтобы общее число единиц (в информационной части плюс бит паритета) было четным. Либо, если включена проверка нулей на нечетность (odd), то общее количество нулей должно быть нечетным. 

Ошибки отслеживаются приемником.

## 15. Синхронный режим работы COM-порта
**Синхронный (synchronous)** -- синхронизируется весь информационный
обмен.

![Selection_011](https://github.com/octolera/OKS/assets/106665253/f02bede9-8ae9-482a-a38f-c4867905643c)

При «простое» передатчик заполняет линию специальными `байтами синхронизации`, тем самым настраивая приемник.

`Все поступающие байты передаются без «обрамления».`

Как и в асинхронном режиме, ошибки отслеживаются приемником. При обнаружении ошибок, а при длительной непрерывной передаче из-за накапливающихся фазовых сдвигов они неизбежно возникают, приемник должен каким-либо дополнительным способом (так как текущую линию задействовать невозможно) приостановить передатчик, чтобы канал вновь заполнился байтами синхронизации.

## 16. Тактирование COM-порта
По своей сути, передатчик и приемник COM-порта представляют собой `программируемые сдвиговые регистры`.

Данные, предварительно записанные в регистр передатчика параллельно, затем последовательно сдвигаются в канал под воздействием тактовых импульсов. В процессе работы UART 16550 тактирование сдвиговых регистров осуществляется непрерывно. Следовательно, данные начинают поступать в канал сразу после их записи в регистр передатчика. 

Заполнение регистра приемника так же происходит «автоматически». Если передаваемые байты записываются слишком быстро, то возникает переполнение очереди FIFO передатчика. Если принимаемые байты считываются слишком медленно, то после переполнение очереди FIFO приемника происходит их потеря.

Тактирование сдвиговых регистров UART 16550 осуществляется с помощью встроенного программируемого `бод-генератора (baud generator)` (тактирование некоторых первых реализаций UART осуществлялось таймером).
Бод-генератор представляет собой **программируемый делитель частоты**.

Выходная частота `бод-генератора Fout` определяется по формуле:
    
    `Fout = Fin / (16 DL)` 
    
где:
    
    `Fin` -- входная частота,
    
    `DL` -- шестнадцатибитная константа, старшая и младшая части которой хранятся в двух регистрах UART (DLL и DLM).

На вход бод-генератора **поступает меандр, получаемый от внешнего кварцевого резонатора**, который тактирует и сам автомат UART. Частота тактирования автомата UART **по крайней мере в 16 раз больше** `Fout`. 

Следует учитывать, что, для того чтобы правильно рассчитать `DL`, необходимо точно знать `Fin`.

Вполне естественно, что на разных материнских платах используют разные микросхемы и разные кварцевые резонаторы. Применительно к современным Super I/O, эта частота может достигать 48 MHz, то есть
совпадать с частотой синхронизации Super I/O. Но, за счет **еще одного деления частоты** (при загрузке ПК BIOS конфигурирует UART инициализируя соответствующие регистры конфигурационного пространства Super I/O), как правило, `Fin` приводится к классическому значению 1,843 MHz.

При этом, если `DL` = 1 (нулевое значение `DL` использовать крайне не рекомендуется), то `Fout` = 115200 Hz.2.0.2.14

Пропускную способность последовательных каналов связи принято оценивать в бодах.

`Один бод (baud) равен одному сигналу в секунду.`

В случае с UART 16550 производительность, измеренная в бодах, совпадает с производительностью, измеренной в битах в секунду (bit/s равно bps). 

## 17. Архитектура COM-порта

`UART 16550`, как и вся БИС Super I/O, как и любая БИС на материнской плате, является **низковольтной**. Но в интерфейсе `RS-232` значения логических уровней совершенно другие, **значительно более «разнесенные»**, что позволяет передавать данные на расстояние до нескольких десятков метров. 

Для получения необходимых значений используют специализированные преобразователи уровней `75232` (аналоги: 75185, 6571 и другие).

Преобразователь уровней `75232` фактически играет роль `трансивера (transceiver, transmitter плюс receiver)`, сочетая функции приемника и передатчика в интерфейсе с определенной физической средой, которой в данном случае является `RS-232`).

![Selection_012](https://github.com/octolera/OKS/assets/106665253/344f07fe-9559-43e7-acbf-1226f0022125)

```
В больших ЭВМ производства второй половины прошлого века для подключения терминалов применялись другие трансиверы -- трансиверы токовой петли (current loop), которые не «разносят» уровни напряжений, а моделируют токовые посылки, что позволяет увеличить расстояние передачи.

Возможность использования токовой петли в ПК была отвергнута изначально.
```

Как и любое устройство ввода-вывода, `UART 16550` содержит регистры управления, регистры состояния, плюс информационные регистры. В стандартной архитектуре ПК для `СOM1` и `COM2` зарезервированы следующие диапазоны программных портов в адресном пространстве ввода-вывода процессора: 

3F8h -- 3FFh и 2F8h -- 2FFh соответственно (но возможности Super I/O позволяют сконфигурировать UART 16550 нестандартно).

Регистры UART 16550 отображаются в соответствующий диапазон следующим образом. Отображение частично зависит от значения `Divisor Latch Access Bit (DLAB)` -- самого старшего (седьмого) бита регистра `LCR`.

Прикладная программа должна в первую очередь корректно **инициализировать соответствующие регистры** `UART`. При этом предоставлена возможность работы по прерываниям. Стандартными аппаратными прерываниями `COM1` и `COM2` являются `IRQ4` и `IRQ3` соответственно (также можно изменить)


![Selection_013](https://github.com/octolera/OKS/assets/106665253/18ce86b5-40b4-450e-b5fd-f7ef71183946)

Назначение регистров:
- `THR (Transmit Holding Register)` -- регистр данных передатчика (точнее буферный регистр сдвигового регистра передатчика).
- `RBR (Receiver Buffer Register)` -- регистр данных приемника (точнее буферный регистр сдвигового регистра приемника).
- `DLL (Divisor Latch Least significant byte)` -- младшая часть константы деления бод-генератора.
- `DLM (Divisor Latch Most significant byte)` -- старшая часть константы деления бод-генератора.
- `IER (Interrupt Enable Register)` -- регистр разрешения прерываний.

    ![Selection_021](https://github.com/octolera/OKS/assets/106665253/5571b72a-081f-47da-911a-dd5421597904)

- `IIR (Interrupt Identification Register)` -- регистр идентификации прерываний.

    ![Selection_019](https://github.com/octolera/OKS/assets/106665253/b9997673-8c2f-4ad1-83c2-68a1d7e34cc9)

  Прерывания UART 16550
  
    ![Selection_020](https://github.com/octolera/OKS/assets/106665253/3decd2b9-5bb6-49d3-90fe-1a182966b8e3)

- `FCR (FIFO Control Register)` -- регистр управления очередями FIFO передатчика и приемника.

    ![Selection_018](https://github.com/octolera/OKS/assets/106665253/fb26cb26-9f13-4575-a7ed-60d63d347205)

- `LCR (Line Control Register)` -- регистр управления линией.

    ![Selection_017](https://github.com/octolera/OKS/assets/106665253/e59110aa-464b-410a-a829-a1b0a7309662)

Включение «залипания» `бита паритета (sticky parity)` приводит к передаче соответствующего константного значения. Включение паузы приводит к приостановке передатчика. При этом передатчик удерживает линию в состоянии логического нуля длительное время, что автоматически переводит в режим паузы и приемник (без уведомления об ошибках).

- `MCR (Modem Control Register)` -- регистр управления модемом.

    ![Selection_016](https://github.com/octolera/OKS/assets/106665253/a3fcde1b-c8ba-4d37-aa1a-d05182553efc)

Включение `loopback-режима` приводит к «закорачиванию» выхода передатчика и входа приемника, что может применяться с целью тестирования `UART`.

- `LSR (Line Status Register)` -- регистр состояния линии.

    ![Selection_015](https://github.com/octolera/OKS/assets/106665253/62e473a2-4cd7-4fc9-8ae0-1013ef52d840)

После считывания очередных данных из приемника нулевой бит `LSR` обнуляется.
После записи очередных данных в передатчик обнуляются пятый и шестой биты `LSR`.
Остальные биты обнуляются после чтения `LSR`.

- `MSR (Modem Status Register)` -- регистр состояния модема.

    ![Selection_014](https://github.com/octolera/OKS/assets/106665253/82703db1-bf1c-462b-92cc-850b59f29a02)

- `SCR (Scratch Pad Register)` -- дополнительный регистр для временного хранения данных, не связанный с функционированием UART.

## 18. Стандарты, близкие к RS-232
С точки зрения топологии, интерфейс `RS-232` обладает одним существенным ограничением, которое закономерно вытекает из его природы.

Он изначально задумывался как интерфейс между разноранговыми устройствами, то есть, по сути дела, как интерфейс для подключения периферийных устройств к компьютеру. **Более двух устройств с помощью RS-232 объединить невозможно**.

В результате, закономерным продолжением стандарта `RS-232` стали два стандарта: `RS-422 (EIA-422-B)` и `RS-485 (EIA-485)`. При этом `RS-422` можно рассматривать как промежуточный на пути к `RS-485` стандарт.

![Selection_022](https://github.com/octolera/OKS/assets/106665253/f8e89950-b4fc-4e46-a40f-ed09c837a1ca)

Для передачи данных посредством интерфейса `RS-485` требуются специальные **трансиверы с гальванической развязкой**, позволяющие реализовать дифференциальный способ передачи сигнала.
**Гальваническая развязка** может быть либо **трансформаторной**, либо **оптронной**.
О СрПД в стандарте не сказано, но, как правило, используют `витую пару (twisted pair)` и разъемы типа `RJ`.

## 19. Структура типового пакета компьютерной сети
Из-за более простой реализации последовательного метода он используется для передачи данных между станциями. Внутри станций используется параллельная обработка.

Для именования порции информации, передаваемой по каналам компьютерных (и не только компьютерных) сетей, используют обобщенный термин `пакет (packet)`.
Пакет содержит последовательно сформированные станцией-передатчиком `поля (fields)`, предназначенные для их интерпретации в станции-приемнике. В общем случае, пакеты могут быть самыми разнообразными (как по структуре, так и по длине), но подавляющее большинство пакетов подпадают под типовую структуру.

Назначение полей:
----Начало----------------------------------------------------------------------
----Header----------------------------------------------------------------------
- `Flag` -- флаг, точнее, флаг начала пакета -- позволяет определить начало пакета.
- `Destination Address` -- адрес назначения -- позволяет указать станцию, для которой предназначен пакет.
- `Source Address` -- адрес источника -- позволяет указать станцию, сгенерировавшую пакет.
- `Other Fields` -- прочие поля -- специфические поля (в том числе и специфические флаги) определенной реализации.
----Payload----------------------------------------------------------------------
- `Data` -- данные -- «полезное» наполнение пакета.
----Trailer----------------------------------------------------------------------
- `FCS (Frame Check Sequence)` -- контрольная сумма -- позволяет проверить целостность пакета.
----Конец----------------------------------------------------------------------

Обычно в байт-ориентированных реализациях длина пакета кратна восьми битам, то есть пакет состоит из так называемых `октетов (octets)`.

Все поля в составе любого пакета можно условно разделить на полезные и служебные.

Полезная `нагрузка (payload)` заключается в собственно данных. Но следует понимать, что вкладываемая в качестве данных информация может носить служебный характер. В некоторых пакетах поле данных не предусмотрено вообще.

Сколько дополнительного трафика порождается в связи с наличием служебных полей оценивают как `overhead`

## 20. Инкапсуляция и ее проявления в компьютерных сетях
В соответствии с концепцией модели OSI, соседние уровни абстрагированы друг от друга. Поэтому вполне закономерно, что на каждом уровне работают со своими структурами данных. При продвижении информации между уровнями возникает необходимость в преобразованиях структур данных. Преобразования выражаются в `инкапсуляции` и `декапсуляции`.

Под `инкапсуляцией (encapsulation)` в КС понимают вкладывание пакета определенного вышестоящего уровня в поле данных пакета смежного нижестоящего уровня в процессе подготовки к передаче, то есть при продвижении сверху вниз. 

Под `декапсуляцией (decapsulation)` понимают обратное действие после приема, то есть при продвижении снизу вверх.

Функционал любого из вышестоящих уровней «знает», какие нижестоящие ресурсы ему необходимы и чем он «располагает». Поэтому процесс инкапсуляции не доставляет трудностей.
А вот функционал нижестоящего уровня при разборе полученных пакетов заранее не знает, какой из вышестоящих подсистем передавать эти пакеты. Проблему решают введением в структуру пакета `служебного поля`, **в котором записывается код протокола вышестоящего уровня**.

Важной особенностью инкапсуляции является то, что в большинство реализаций заложена возможность передавать пакеты, относящиеся к некоторому протоколу некоторого уровня (например, сетевого), вкладывая их в пакеты другого протокола того же уровня, то есть организовывать `туннелирование (tunneling)`.

Инкапсуляция имеет еще ряд проявлений.

Если при выполнении инкапсуляции данные некоторого уровня не помещаются в поле отведенной длины, то можно прибегнуть к `фрагментации (fragmentation)` -- разбить данные на фрагменты и передать цепочку пакетов. Принимающая сторона будет вынуждена выполнить `дефрагментацию (defragmentation)`.
Поле, отвечающее за длину поля данных, может быть не предусмотрено. Если длина поля данных фиксирована, а данных не хватает, то возникает необходимость в `автодополнении` (например, нулями).

`Перемежение (interleaving)` позволяет «распараллелить» пересылку пакетов или их фрагментов и заключается в одновременном задействовании нескольких каналов.
Особенно это применимо в низкоскоростных СрПД. 
`Фрагментация` (при наличии альтернативных путей в СПД) и `перемежение` могут привести к «перемешиванию» пакетов и, как следствие, **разрушению сообщения**.

Контроль за порядком фрагментов может быть возложен как на **протокол подверженного фрагментации уровня**, так и на **протокол вышестоящего уровня**.

Названия структурных единиц передаваемой информации в привязке к уровням модели OSI:
- L1 -- сигналы (signals).
- L2 -- кадры (frames).
- L3 -- собственно пакеты (packets).
- L4 + L5 -- сегменты (segments).
- L6 + L7 -- сообщения (messages).
## 21. Бит-стаффинг
При `бит-стаффинге` совпадающая с флагом последовательность разбивается с помощью вставки дополнительно бита с соответствующим значением.

`Реализуется аппаратно. Обычно применяется при задействовании синхронных СрПД`

Применение `бит-стаффинга` приводит к увеличению длины пакета. Теоретически, с целью уменьшения связанных с бит-стаффингом «издержек», следует стремиться к минимизации количества вставок: разбивающий бит нужно вставлять после наиболее длинной уникальной подпоследовательности в флаговой последовательности.

Классическим флагом начала пакета является байт со значением 01111110b (7Eh).

![Selection_023](https://github.com/octolera/OKS/assets/106665253/21d80ecd-6ac9-4911-8243-fab8aed810ef)

На передающей стороне после нуля и шести единиц всегда вставляется седьмая единица, а на принимающей стороне единица после нуля и шести единиц всегда удаляется.

```
Следует отметить, что на практике (например, применительно к HDLC) бит-стаффинг выполняется вставкой нуля после пяти единиц.
```

## 22. Байт-стаффинг
`Реализуется программно. Обычно применяется при задействовании асинхронных СрПД`

В сравнении с алгоритмами бит-стаффинга, алгоритмы байт-стаффинга манипулируют байтами, являются более сложными и более «затратными», но при программировании они позволяют избежать битовых операций.

![Selection_024](https://github.com/octolera/OKS/assets/106665253/74673860-905e-432f-a24d-655890148cef)

Единственным способом обеспечения уникальности флагового байта является замена совпадающего с ним байта на некий выбранный другой. Но возникает вопрос, как принимающая сторона отличит замененный байт от такого же незамененного. Решением является применение так называемого `ESC-символа`. Наличие `ESC-символа` говорит станции-приемнику о факте замены, а следующий за `ESC-символом` символ -- код замены позволяет определить какая замена была осуществлена. Байт-стаффингу можно подвергать **целые группы символов**.

## 23. Особенности линейного кодирования и классификация линейных кодов, применяемых в компьютерных сетях
Не следует путать линейное кодирование с модуляцией, выполняемой на физическом уровне. Несмотря на то, что часто эти процессы связаны неразрывно, **линейное кодирование все-таки следует рассматривать как надстройку над модуляцией**.

Одной из основных предпосылок для разработки линейных кодов, является проблема, проявляющаяся во многих системах передачи цифровой (не только) информации, известная как девиацией несущей (carrier deviation). Очевидно, передатчик и приемник должны работать на одной частоте. В большинстве случаев, передатчик и приемник имеют разные источники
синхронизации. При этом тактовые генераторы далеко не идентичны. Если состояние линии очень долго не изменяется, что происходит при передаче очень длинных нулевых либо единичных последовательностей с использованием классической амплитудной модуляции цифровых цепей (логический ноль соответствует земле, а логическая единица некоторому положительному потенциалу относительно земли), то приемнику «цепляться не за что». В результате накапливаются фазовые сдвиги, что в конце концов приводит к возникновению ошибок. 

Современная схемотехническая база для борьбы с девиацией несущей имеет в распоряжении блок `ФАПЧ (фазовой автоподстройки частоты)`, позволяющий автоматически подстраивать тактовый генератор приемника к тактовому генератору передатчика. 
Наиболее близкий англоязычный термин -- `PLL (Phased-Locked Loop)`.

Все линейные коды, в той или иной степени, **направлены на преобразование битовых последовательностей**, чтобы в линии постоянно происходили изменения. В том числе, за счет равномерного распределения нулей и единиц.

Шесть факторов, влияющих на классификацию линейных кодов:
1. Кодирование уровнями либо переходами.
2. Наличие инвертирования.
3. Однополярность либо многополярность.
4. Наличие так называемого «возврата к нулю».
5. Наличие самосинхронизации.
6. Наличие перестановки или подмены битов.

Линейные коды, применяемые в оптических каналах имеют особенности в сравнении с кодами для проводниковых каналов. 

Пример: 
- `TS-FO (Three of Six -- Fiber Optical)`, `RZ carrier-suppressed`, `RZ
alternate-phase`

## 24. Линейные коды без возврата к нулю и с возвратом к нулю
### NRZ
`NRZ`-коды выражаются в изменении уровней между тактами. В простейших случаях, логические уровни в исходной последовательности не преобразуются совсем либо инвертируются. Более сложными случаями являются `space` и `mark`. При `space`-варианте ноль во входной последовательности кодируется сменой текущего уровня в выходной, а единица -- сохранением текущего уровня. При `mark`-варианте, наоборот, единицы в исходной последовательности приводят к переключению уровней. Начальное состояние значения не имеет. `Space` и `mark` инверсны друг относительно друга. `NRZ`-коды могут быть однополярными и двухполярными. Требуется наличие дополнительной цепи для тактирования. 

![Selection_025](https://github.com/octolera/OKS/assets/106665253/7bf88aa2-cffd-4d13-a51b-04de6c05fa62)

Примеры технологий с применением `NRZ`-кодов: `RS-232`, `USB`, `HDLC`.

### RZ
`RZ`-коды так же выражаются в изменении уровней между тактами, но на половине каждого такта всегда происходит возврат к нулю (земле). Двухполярные RZ-коды обладают свойством самосинхронизации. Пример технологии с применением `RZ`- кода: `IrDA`.

![Selection_026](https://github.com/octolera/OKS/assets/106665253/d4f3a1db-2e9f-4d55-81f3-88e8195b0802)

## 25. Манчестерские и многоуровневые линейные коды
Манчестерские коды выражаются в переходах между уровнями во время тактов, поэтому их иногда называют фазовыми кодами.
Есть два «равноправных» варианта собственно манчестерского кода. Ноль во входной последовательности заменяется на переход от единицы к нулю, а единица заменяется на переход от нуля к единице. Либо наоборот.
**Манчестерские коды обладают свойством самосинхронизации**.

Еще несколько кодов близки к манчестерскому.
Согласно `коду Миллера (Miller)`, ноль соответствует отсутствию перехода во время такта, единица соответствует переходу во время такта, плюс между двумя нулями всегда выполняется смена уровня.

Согласно коду `Split Phase` учитывается направление предыдущего перехода. При `space`-варианте ноль соответствует переходу во время такта в направлении, противоположном направлению предыдущего перехода, единица соответствуют переходу во время такта в направлении, совпадающем с направлением предыдущего перехода. При `mark`-варианте
«роли» нулей и единиц из входной последовательности инвертируются. 

Согласно коду `Biphase`, кроме возможных переходов во время тактов, всегда выполняется смена уровня между тактами. При `space`-варианте ноль соответствуют переходу во время такта, единица соответствуют отсутствию перехода во время такта. При `mark`-варианте «роли» нулей и единиц из
входной последовательности инвертируются. 

Примеры технологий с применением манчестерских кодов: `Ethernet`, `Token
Ring`, некоторые `IR`-технологии.

![Selection_027](https://github.com/octolera/OKS/assets/106665253/0e3e1159-89f3-4732-bc89-97947d9b649f)

## 26. Блочные линейные коды
Блочные коды выражаются в замене блоков битов из входной последовательности на большие (как правило) по размеру блоки битов в выходной последовательности.Блочные коды могут комбинироваться с вышеперечисленными кодами. 

В связи с избыточностью блочных кодов, во многих из них предусмотрены контрольные последовательности, которые, по сути, являются управляющими символами.
Первым примером может служить код `4b/5b`, применяемый в `Fast Ethernet` и `CDDI`.

![Selection_028](https://github.com/octolera/OKS/assets/106665253/9270a8bd-d904-41d2-bb3e-abd3a21db71f)

Более сложным примером может служить код `8b/10b`, применяемый в оптических вариантах `Gigabit Ethernet`.

Биты входного блока обозначают как ABCDEFGH -- от младшего к старшему, выходного abcdefghij -- так же от младшего к старшему. Входной блок разбивается на два подблока: x из пяти битов и y из трех битов. Поэтому выходной код представляет собой конкатенацию двух кодов: `5b/6b` и `3b/4b`. Кроме собственно блоков данных D, имеются контрольные блоки K, которые кодируют альтернативно. 

Таким образом, входной блок обозначают как Dx.y либо Kx.y. Наконец, в код `8b/10b` заложена гибкая система уравнивания количества нулей и количества единиц, заключающаяся в динамическом выборе блока для замены (одного из двух) исходя из текущего значения так называемого `RD (Running Disparity)`. Предусмотрено два значение `RD`: -1 и +1. При выборе текущего значения `RD` учитывается предыдущее значение `RD` и соотношение нулей и единиц во входном блоке (плюс есть исключения).

![Selection_029](https://github.com/octolera/OKS/assets/106665253/4ed113cc-1ca1-464b-8a17-89eaebb97c6a)

![Selection_030](https://github.com/octolera/OKS/assets/106665253/e6aca55b-c4d9-407c-a286-64094f612917)

## 27. Поля Галуа и их применение в компьютерных сетях
https://habr.com/ru/articles/212095/

В теории помехоустойчивого кодирования очень важное место занимают
поля Галуа, но чтобы к ним «подойти» нужно сделать ряд шагов.

Некоторую операцию * называют бинарной если после ее применения к
двум любым элементам a и b некоторого множества получают элемент c,
принадлежащий тому же множеству: a * b = c.
А соответствующее непустое множество S называют замкнутым
относительно бинарной операции *.
Элемент e множества называют нейтральным если, после бинарной
операции над этим элементом и некоторым другим, другой участвовавший в
операции элемент не изменяется: a * e = a.
Два элемента множества называют обратными (относительно друг друга)
если в результате бинарной операции над ними получают нейтральный
элемент: a * b = e.

Множество G называют группой если для него определена бинарная
операция * и:
1. Операция * является ассоциативной: (a * b) * c = a * (b * c) --
соответствует умножению.
2. Существует нейтральный элемент -- соответствует единице.
3. Имеется унарная операция, позволяющая получить обратный элементу
a элемент -- соответствует a-1.

Группу называют абелевой если операция * коммутативна: a * b = b * a.
Если для группы определена операция умножения (a * b = ab), то группу
называют мультипликативной.
Мультипликативную группу называют циклической если в ней существует
такой элемент, что все остальные элементы являются степенями этого
элемента: b = ak. А сам элемент a называют образующим группу.

Классом вычетов по модулю n, принадлежащему множеству натуральных
чисел N, называют подмножество элементов из множества целых чисел Z,
имеющих одинаковый остаток от деления на n.
[a] -- класс вычетов, одним из элементов которого является a.
Группу, образованную множеством классов вычетов по модулю n,
называют группой классов вычетов по модулю n.

Группу называют конечной если группа состоит из конечного числа
элементов.
Число элементов |G| конечной группы называют ее порядком.

Два целых числа сравнимы (эквивалентно равны) по модулю
натурального числа n если при делении на n они дают одинаковые остатки: a
≡ b (mod n).

Отображение f: G -> H группы G в группу H называют гомоморфным если
оно сохраняет операцию группы G. Отображение изоморфно если оно
взаимно однозначно.
Отображение f: G -> G называют эпиморфным, изоморфное отображение
f: G -> G называют автоморфным.

Множество R называют кольцом если для множества определены две
бинарные операции # и * такие что:
1. Множество R является абелевой группой относительно операции # --
соответствует сложению.
2. Операция * является ассоциативной.
3. Выполняется закон дистрибутивности: a * (b # c) = a * b # a * c.
Если для группы определена операция сложения (a # b = a + b), то группу
называют аддитивной. Единичный элемент аддитивной группы соответствует
нулю. Обратный элементу a элемент аддитивной группы соответствует -a.
На операцию * можно накладывать дополнительные ограничения. Если в
кольце присутствует единица, то кольцо называют кольцом с единицей.
При выполнении закона коммутативности кольцо называют коммутативным.
Коммутативное кольцо называют целостным если его единица не равна
нулю и a * b = 0 только при a = 0 или b = 0

Кольцо называют телом если кроме нуля в кольце существуют другие
элементы и эти элементы образуют группу относительно операции *.
Наконец, коммутативное тело F называют полем.
Подгруппой, подкольцом, подполем называют подмножества сохраняющие соответствующие свойства.
Поле, не содержащее подполей, называют простым. Простым будет
поле, порядок которого равен простому числу.

Подкольцо I кольца R называют его идеалом (двухсторонним идеалом)
если для любой пары элементов a из I и r из R их произведение принадлежит
I.
Подкольцо R/I классов вычетов по модулю идеала I из кольца R называют
факторкольцом кольца R по идеалу I.
Наименьшее из натуральных чисел n, такое что для любого элемента r из
кольца R выполняется равенство n * r = 0, называют характеристикой
кольца R.

Согласно теореме, каждое конечное целостное кольцо образует поле.
Согласно другой теореме, характеристикой конечного поля является
простое число.
Поле GF(p) из целых чисел 0, 1 ... p - 1, порожденное в результате
отображения f: Z/p -> GF(p), где Z/p -- факторкольцо множества целых чисел,
в котором роль идеала играет простое число p, и f([a]) = a, называют полем
Галуа (Galois field) порядка p.
При вычислениях с элементами поля Галуа используют целочисленную
арифметику с приведением по соответствующему модулю.

дно и то же число можно записать самыми разными способами. Число
можно рассматривать и как значение полинома.
Полиномом (многочленом) одной переменной называют выражение:
n
f(x) = ∑aixi = anxn + an-1xn-1 + ... + a0 .
i=0
В случае полинома над кольцом, коэффициенты ai соответствуют
элементам кольца, а переменная x кольцу не принадлежит.
Два полинома f(x) и g(x) называют равными если равны их степени и
равны коэффициенты при одинаковых степенях переменной.
Если старший коэффициент полинома равен единице, то полином
называют приведенным.

Тривиальными делителями полинома называют сам полином и полином
равный 1.
Полином над полем F называют неприводимым над этим полем если
полином допускает только тривиальное разложение, то есть у полинома нет
нетривиальных делителей из F (с точностью до домножения на ненулевую
константу).

Для практического применения полей Галуа в компьютерных системах необходимо перейти от скалярного представления к векторному.
Расширенное поле Галуа GF(pn) можно рассматривать как векторное пространство, где простое число p является характеристикой поля и соответствует количеству состояний разряда вектора, а n является степенью поля над его простым подполем и соответствует количеству разрядов вектора.
Поскольку в обычных компьютерных системах разряды регистров бинарные, то наибольший интерес представляют поля GF(2n).

Сложение бинарных векторов (совпадает с вычитанием) проблему не представляет и соответствует поразрядной операции xor. А вот с умножением и делением дела обстоят значительно сложнее. Скалярное произведение не подходит, так как его результат может «выйти» за пределы поля. Векторное произведение определено только для трехразрядных векторов.
Полиномиальное представление так же с ходу не решает проблему, так как произведение полиномов опять же «выводит» за пределы поля. Для обеспечения конечности поля Галуа, полученный в результате произведения полином нужно привести. Это достигают путем деления на некий выбранный полином степени n. Ясно, что выбирать можно разные полиномы. Выбор другого полинома приведет к другим результатам умножения и, соответственно, к другому полю GF(pn).

**Выбранный для построения поля Галуа полином называют порождающим (образующим)**

Деление векторов в математике не известно.
После перехода на язык полиномов, опять же для обеспечения конечности поля Галуа, деление всегда должно быть безостаточным. Деление можно представить как умножение полинома-делимого на полином, обратный делителю. При этом для достижения цели на основании математических выкладок, необходимо ввести еще одно ограничение: порождающий полином
должен быть неприводимым по модулю p (например, если p = 2 и n = 4, то полином x4 + 1 (число 17) не подходит, так как x4 + 1 ≡ (x2 + 1)2 (mod 2) ).

**Возведение в степень обладает цикличностью**.

## 28. Модель помехоустойчивого канала связи и теорема Шеннона
Считается, что начало помехоустойчивому кодированию положила **теорема Шеннона**, утверждающая что любой дискретный канал связи имеет конечную пропускную способность и этот канал может быть задействован для передачи информации со сколь угодно большой степенью достоверности, не смотря на наличие помех.

![Selection_031](https://github.com/octolera/OKS/assets/106665253/980bb9cd-fff8-48c5-95aa-d54f60185c15)
Передаваемое сообщение разбивается на блоки фиксированного размера
a из k битов a1, a2 ... ak.
Кодер выполняет функцию f, называемую схемой кодирования, и тем
самым преобразует вектор а в вектор c из n > k битов c1, c2 ... cn, называемый
кодовым словом.
В процессе пересылки кодового слова по каналу связи на него
накладывается вектор ошибок e, в котором единичные биты соответствуют
искажениям.
После применения декодером схемы декодирования g получается вектор
a', в идеале совпадающий с исходным вектором a.

Подобная схема кодирования является избыточной. На практике всегда
ищут компромисс между степенью обеспечения достоверности при передаче
и вычислительной сложностью кодов (что в первую очередь отражается на
скорости декодирования).
В КС множество кодовых слов получается из множества исходных слов
как отображение из конечного поля GF(2k) в конечное поле GF(2n).
При более простых схемах кодирования, в кодовом слове сначала
располагаются биты входного сообщения, называемые информационными, а
за ними дополнительные биты, называемые проверочными: a1, a2 ... ak, ck+1,
ck+2 ... cn.
В более сложных случаях проверочные биты чередуются с
информационными.

## 29. Линейные помехоустойчивые коды, включая коды Хэмминга и циклические коды
Схему кодирования удобно представлять в матричном виде.

![Selection_031](https://github.com/octolera/OKS/assets/106665253/1e39cfc2-be01-4e60-bdf2-c7c57ee9f256)

Видно, что проверочные уравнения образуют систему линейных
уравнений. Следовательно, отображение f (схема кодирования) является
**линейным**.

Если H -- матрица размером (n - k) × n ранга n - k и H cT = 0, то множество
всех n-разрядных векторов, входящих в поле GF(2n) (в общем случае GF(pn)),
называют линейным (n,k)-кодом (в математическом смысле) длины n и
размерности k. А матрицу H называют проверочной.
Линейный код по-другому называют групповым, так как множество
кодовых слов можно рассматривать как подгруппу в отношении поля GF(2n).
Линейный код называют систематическим (разделенным) если
расположение проверочных битов известно (не важно где они находятся), то
есть если H = [A In - k], где A -- матрица размером (n - k) × k, а In - k --
единичная матрица ранга n - k.
Матрицу G = [Ik-AT] размером k × n называют кодирующей
(порождающей) матрицей систематического кода.
Кодирующая и проверочная матрицы связаны следующим образом:
GHT = 0.

Перед выбором того либо иного помехоустойчивого кода всегда нужно
определиться, что требуется от кода. Если перефразировать, то нужно
ответить на два вопроса:
1. Сколько бинарных ошибок код должен обнаруживать.
2. Сколько бинарных ошибок код должен исправлять.
Исправлять ошибки значительно сложнее, чем обнаруживать.
Применительно ко многим кодам, исправление ошибки подразумевает
нахождение ее позиции.

```
В общем случае ошибки носят случайный характер. Множественные
ошибки могут быть взаимозависимыми, то есть образовывать модули ошибок.
Если ошибки расположены рядом, то они образуют пакет ошибок (частный
случай модуля).
```
### Бинарным кодом Хэмминга
называют код длины n = 2m - 1, m ≥2 с
проверочной матрицей H размером m × (2m - 1), в которой столбцы
соответствуют записи 1, 2 ... 2m - 1 в двоичной системе счисления.
Код Хэмминга позволяет исправлять одиночную ошибку и обнаруживать
множественные ошибки.

Число координат (позиций), которыми два вектора x и y различаются
называют **расстоянием Хэмминга** -- `d(x,y)`.
Число ненулевых позиций вектора x называют **весом Хэмминга** -- `w(x)`.
Видно, что **расстояние Хэмминга** показывает количество возникших
ошибок.

### Циклические коды являются особо выделяемой подгруппой линейных кодов.
Циклическим кодом называют линейный код, удовлетворяющий
дополнительному условию: если вектор a0, a1 ... an-1 является кодовым
словом, то и его циклический сдвиг an-1, a0 ... an-2 так же является кодовым
словом.
Циклический код позволяет исправлять одну и более ошибок и
обнаруживать множественные ошибки (зависит от параметров).

Базовая идея **циклического кодирования** состоит в том, чтобы в качестве
проверочных битов передавать остаток от деления информационных битов
на некоторое выбранное число.
После приема снова выполняется деление уже возможно искаженных
информационных битов на то же самое число и сравниваются остатки.
Если остатки совпадают, то данные с определенной вероятностью
приняты без ошибок.

На практике же деление выполняется **по правилам арифметики полей
Галуа**, то есть без учета переносов.
Информационные биты, то есть делимое, соответствуют
информационному полиному.
Делитель соответствует **порождающему (образующему) полиному**.
Частное в процессе кодирования не используется и поэтому
«отбрасывается».

Для того чтобы максимально разнообразить остатки в качестве
порождающего полинома должен выбираться **неприводимый полином**.

Существуют два подхода к реализации циклического кода на стороне
приемника:
1. Согласно базовой идее, описанной выше.
2. На порождающий полином делится все принятое кодовое слово. Если
ошибок не произошло, то остаток будет нулевым.

Оба подхода равноценны.

## 30. Классификация помехоустойчивых кодов
За достаточно длительную историю развития прикладной теории
кодирования, как науки, было придумано очень много помехоустойчивых
кодов.

Основные группы помехоустойчивых кодов:
1. Линейные коды, в том числе: коды Хэмминга, циклические коды, БЧХ-
коды (коды Боуза-Чоудхури-Хоквингема), РМ-коды (коды Рида-Маллера),
итеративные коды, коды на основе матриц Адамара, симплексные коды и
некоторые другие.
2. Коды для контроля модульных и пакетных ошибок, в том числе: РС-
коды (коды Рида-Соломона), низкоплотные модульные коды, векторные
модульные коды, итеративные модульные коды и некоторые другие.
3. Сверточные коды.
4. Арифметические коды.
5. Низкоскоростные коды, в том числе: коды максимальной длины,
нелинейные коды, D-коды и некоторые другие.

## 31. Классификация каналов в сети передачи данных
На физическом уровне оперируют с сигналами, поэтому концентрируются
на отдельно взятом передатчике, отдельно взятом приемнике и
последовательном канале, который их связывает. Для обеспечения
модуляции этого вполне достаточно. **При этом приемник активен всегда, а
передатчик включается по мере надобности**.

С точки зрения направленности, последовательный канал может
функционировать в одном из трех режимов:

1. Симплексном (simplex) -- передача данных по каналу возможна только
в одном направлении.
2. Полудуплексном (semiduplex) -- данные могут передаваться в обоих
направлениях, но в один момент времени возможна передача только в одном
направлении.
3. Полнодуплексном (full duplex) -- данные могут передаваться в обоих
направлениях одновременно.

Сейчас в КС доминируют полнодуплексные каналы

Топология «возникает» на канальном уровне, когда речь идет об
организации сегмента.

Последовательный канал может быть:
1. `Выделенным (leased)` -- зарезервирован за определенной парой
станций-абонентов.
2. `Разделяемым (shared)` -- может использоваться несколькими
станциями-абонентами.

Причем канал, который не может разделяться несколькими станциями-
передатчиками одновременно, в отечественной литературе принято называть
моноканалом. Во многих реализациях ситуация именно такая.

С точки зрения общей организации процесса пересылки данных, все СПД
можно разделить на два фундаментальных типа:

1. `СПД с коммутацией пакетов (packet-switched)` -- в структуру пакетов
включают адреса станций-абонентов; каждое устройство-посредник
определяет дальнейший путь на основании анализа адресов назначения;
каждый из пакетов в цепочке пересылается независимо от остальных
(следует учитывать, что в сложных СПД имеются альтернативные пути
пересылки).
2. `СПД с коммутацией каналов (circuit-switched)` -- адреса станций-
абонентов в структуру пакетов (кадров) не включают; сначала, по запросу
станции-передатчика, на основании запрашиваемого адреса, СПД
«прокладывает» к вызываемой станции канал, называемый коммутируемым;
каналы-звенья могут быть как выбранными «целиком» каналами (как правило
между оконечными устройствами и устройствами-посредниками), так и
выбранными подканалами каналов с частотным или временны'м
разделением (как правило между устройствами-посредниками); затем
созданный канал используется для пересылки пакетов (кадров).

## 32. Логические и физические топологии LAN
режде всего, топологии делят на два типа:
1. `Point-to-point` -- топология «точка к точке» -- связывает только две
станции.
2. `Multi-access (multipoint-to-multipoint)` -- топология с множественным
доступом -- связывает более двух станций.
Эти два типа позволяют организовывать двунаправленные каналы между
любым требующимся количеством абонентов, поэтому их реализуют
наиболее часто.
Применительно к однонаправленным каналам можно добавить еще два
пункта:

+3. `Point-to-multipoint` -- иногда.

+4. `Multipoint-to-point` -- очень редко.

Менее двух станций в сегменте быть не может.

В общем случае, направленность каналов может «накладываться» на
топологии по-разному. Например, кольцо может быть однонаправленным и
двунаправленным.
Сегмент может иметь и `гибридную топологию (hybrid topology)`.

Если
топологически
классифицировать
аппаратные
технологии
(охватывающие два нижних уровня модели OSI), то есть еще два ракурса:
1. `Физическая топопогия (physical topology)` -- отражает физические связи
между устройствами.
2. `Логическая топопология (logical topology)` -- отражает логические связи
между устройствами.

Часто логическая топология не совпадает с физической.

Характерными топологиями ЛКС являются:
1. `Шина (bus)`.
2. `Кольцо (ring)`.
+3. `Звезда (star)`.

```
Сегменты соединяют произвольным образом, поэтому на сетевом уровне
уместно говорить о топологии с произвольными связями, хотя топологию в
отношении третьего уровня упоминают весьма редко.
Протоколы сетевого уровня обычно разрабатывают топологически
независимыми.

Начиная с транспортного уровня, топологии применимы к связям между
программами, производящими и потребляющими сетевые услуги, поэтому
могут быть только логическими.
Здесь характерными топологиями являются:
1. Point-to-point -- при двунаправленной передаче.
2. Point-to-multipoint -- при однонаправленной передаче.
```

## 33. Логические и физические топологии WAN и RAS
Характерными топологиями `ГКС` являются:
- 1. `Сеть (произвольно связанная) (mesh)`.
- +2. `Ступица со спицами (hub-and-spoke)`.
- +3. `Полносвязная сеть (full-mesh)`.
- 
Характерной `RAS`-топологией является `point-to-point`.
Можно сказать, что для `ГКС`-технологий существует только одна типичная
топология (произвольно связанная сеть), остальные можно рассматривать как
ее частные случаи.

Для `RAS`-технологий существует только одна типичная топология.
На начальных этапах изучения, Cisco не отделяет RAS от ГКС.

## 34. Особенности случайных методов доступа к моноканалу
Все случайные методы основаны на использовании генератора
случайных чисел (поэтому их так и называют), который позволяет делать
случайные задержки при доступе к моноканалу, а значит и с определенной
степенью вероятности избегать коллизии.

На эффективность случайных методов наиболее существенное влияние
оказывают следующие факторы:
- количество взаимодействующих станций;
- инертность среды передачи данных;
- длина кадра;
- частота синхронизации.

С точки зрения изучения случайных методов доступа к моноканалу
наиболее наглядным примером является классический алгоритм CSMA/CD
(Carrier Sense Multiple Access with Collision Detection) -- множественный доступ
с прослушиванием несущей и обнаружением коллизий, описанный в
стандарте Ethernet (IEEE 802.3).

## 35. CSMA/CD (Ethernet)
передача кадра

![Selection_034](https://github.com/octolera/OKS/assets/106665253/6117f34a-8337-4afb-9470-53221178b9a0)

получение кадра

![Selection_033](https://github.com/octolera/OKS/assets/106665253/cc2e3c4d-84a3-4b98-b5c7-a4f71b401785)

Задержка перед началом очередной попытки передачи после коллизии
`(backoff)` измеряется в так называемых слот-таймах, количество которых
является случайным целым числом `r`:
0 ≤ `r` ≤ 2k ,
где
`k` = min (n, 10) ,
где `n` -- номер попытки.
После превышения счетчиком попыток некоторого порогового значения
дальнейшие попытки считаются бесперспективными.
Значение `k` не может быть больше 10.

Качество диспетчеризации при обработке коллизий по большому счету
зависит от одного базового параметра.

`Cлот-тайм (slot time)` является минимальной неделимой единицей
времени при диспетчеризации и подбирается с учетом многих других
параметров. По крайней мере, он должен быть больше суммы удвоенного
времени прохождения сигнала по сегменту и времени передачи jam-сигнала.

Каждая обнаружившая коллизию станция передает специальный `jam-
сигнал` некоторой длительности (значение стандартом не регламентируется).

`Jam-сигнал` выполняет две важные функции. Во-первых, является
признаком возникновения коллизии, что позволяет другим станциям сразу
«увидеть» коллизию (столкнувшиеся передатчики, выставившие jam-сигнал, и
так знают о коллизии). Во-вторых, позволяет синхронизировать время начала отсчетов случайных задержек.

## 36. Кадр Ethernet
![Selection_035](https://github.com/octolera/OKS/assets/106665253/c23e73c1-b306-463c-a965-864d33be4f5a)

Поля:
- `Preamble` -- преамбула.
- `SFD (Start Frame Delimiter)` -- разграничитель начала кадра.
- `DA (Destination Address)` -- адрес назначения.
- `SA (Source Address)` -- адрес источника.
- `Length/Type` -- длина либо тип.
- `Data` -- данные.
- `Pad` -- наполнитель.
- `FCS (Frame Check Sequence)` -- контрольная сумма.
- `Extension` -- расширитель.

Предусмотрены полудуплексный и полнодуплексный режимы, «поведение» в которых несколько различается.
В качестве `преамбулы` выступают семь байтов со значением `10101010b`, а
в качестве `SFD` -- байт со значением `10101011b`.
При сборке кадра учитываются ограничения на его длину. Ограничивается
не только максимальная длина, а и минимальная.
При недостаче в поле данных вслед за ним в кадр вставляются
дополнительные октеты-наполнители (значения стандартом не регламентируются).
Параметр `MTU (Maximum Transmission Unit)` определяет максимальный
размер вкладываемых данных. Применительно к `Ethernet`, если значение
поля `Length/Type` больше либо равно `1536 (600h)`, то указывает тип
инкапсулируемых данных.
При необходимости, октеты-расширители дополняет кадр до тайм-слота
(только в полудуплексном режиме).

`Ethernet`-заголовок имеет фиксированную длину.
Но, поскольку многие базирующиеся на `Ethernet` технологии (например,
виланы) имеют собственные подзаголовки, заголовок, а следовательно и весь
кадр, может увеличиться, правда незначительно и не затрагивая MTU (такие
кадры иногда называют `baby giant`).
Некоторые технологии предусматривают значительное увеличение кадра
уже за счет увеличения MTU. Например, параметр MTU технологии `FCoE
(Fibre Channel over Ethernet)` равен `2500` байтам (такие кадры иногда
называют `mini jumbo`).

Наконец, многие производители оборудования `Ethernet` предусмотрели
нестандартное (но в большинстве случаев совместимое) административное
увеличение MTU вплоть до 9000 байтов -- в первую очередь, для
оптимизации пересылки больших объемов данных. Такие Ethernet-кадры
называют гигантскими (`jumbo`).

## 37. CSMA/CA (Wi-Fi)

Еще одним примером случайных методов доступа к моноканалу является
гораздо более сложный алгоритм `CSMA/CA (Carrier Sense Multiple Access with
Collision Avoidance)` -- множественный доступ с прослушиванием несущей и
избеганием коллизий, описанный в стандарте `Wi-Fi (IEEE 802.11)`.

Для понимания алгоритма необходимо ввести термины из стандарта.

Применительно к Wi-Fi, MAC-подуровень канального уровня поделен еще
на два слоя.

На нижнем слое расположен только один блок под названием `DCF
(Distributed Coordination Function)` -- функционал распределенного
координируемого взаимодействия. DCF и составляет ядро алгоритма
`CSMA/CA`. Все станции сегмента должны поддерживать `DCF`.
Над `DCF` расположены:
- `PCF (Point Coordination Function)` -- функционал координируемого
взаимодействия с использованием станции-координатора.
- `HCF (Hybrid Coordination Function)` -- функционал гибридного
координируемого взаимодействия.
- `MCF (Mesh Coordination Function)` -- функционал сеточного
координируемого взаимодействия

Из них формируются следующие опциональные блоки:
- `PCF`.
- `HCCA (HCF Controlled Access)`.
- `EDCA (HCF/MCF Contention Access)`.
- `MCCA (MCF Controlled Access)`.
Кроме `DCF`, наибольший интерес представляет `PCF`. Остальные блоки
предназначены для поддержки `QoS`.

Cтандартом предусмотрены целых шесть вариантов отслеживаемых
межкадровых интервалов -- `IFSes (InterFrame Spaces)`:
- `RIFS (Reduced IFS)` -- сокращенный.
- `SIFS (Short IFS)` -- короткий.
- `PIFS (PCF IFS)` -- для `PCF`.
- `DIFS (DCF IFS)` -- для `DCF`.
- `AIFS (Arbitration IFS)` -- для `QoS`-арбитража.
- `EIFS (Extended IFS)` -- расширенный.

Отслеживание различных `IFSes` в различных ситуациях влияет на
способность станции «видеть щели» между кадрами, а значит и на
способность «вклиниваться» в пересылку.
`IFSes` рассчитывают на основании комплекса параметров.
Кроме интервала `DIFS`, используемого функционалом `DCF`, наиболее
интересны `SIFS` и `PIFS`.

![Selection_038](https://github.com/octolera/OKS/assets/106665253/ed9f55a2-6736-43c5-aa3c-0d69c08a4941)

**Случайная задержка** измеряется в `слот-таймах`, как и в `Ethernet`, но
алгоритм другой. Количество слот-таймов является случайным целым числом
`Random`:
`0 ≤ Random ≤ CW` ,
где `CW (contention window)` -- так называемое окно состязаний:
`CWmin ≤ CW ≤ CWmax` ,
и берется из ряда: 7, 15, 31 ... (два в некоторой степени минус один).

Крайние значения зависят от способа модуляции (типичное значение
`CWmin` -- 15, типичное значение `CWmax` -- 1023).

Предусмотрены два счетчика попыток: `SRC (Short Retry Count)` и `LRC
(Long Retry Count)`. Количество попыток ограничивается. Выбор значения
зависит от физического уровня.

![Selection_036](https://github.com/octolera/OKS/assets/106665253/80542fee-8470-4a1a-b695-a8a08e92082c)

![Selection_037](https://github.com/octolera/OKS/assets/106665253/cf4f616c-c070-41d1-ab33-2ff5c256344e)

### CSMA/CA. Расширение RTS/CTS
Для беспроводных каналов свойственны две проблемы, которые
получили следующие названия:
- `Hidden node problem` -- проблема скрытой станции.
- `Exposed node problem` -- проблема доступной станции.
  
Предполагается, что все станции взаимодействуют в рамках одного
канала.

**Проблему скрытой станции** можно сформулировать так: станция C может
ошибочно начать передачу станции B, так как не может «услышать» что
станция A уже передает станции B (станция A «скрыта» от станции C).

**Проблему доступной станции** можно сформулировать так: станция C, зная
о взаимодействии станций A и B, не может передать станции D во время
пассивности станции B, а могла бы, поскольку считает канал занятым
ошибочно (станция C «доступна» для станции D).

Частично решить проблемы помогает опциональное расширение `RTS/CTS`.

![Selection_040](https://github.com/octolera/OKS/assets/106665253/af84ae1f-167d-4c0d-a9a7-7b860e6f5c3c)

Кадры, поступившие на канальный уровень для дальнейшей передачи,
называются `MSDUs (MAC Service Data Units)` и могут быть размером до 2304 байтов.

`MSDUs` разбиваются на меньшие фрагменты, называемые `MPDUs (MAC
Protocol Data Units)`, которые передаются в **пакетном** режиме. Длина
фрагментов также ограничивается (например, 4095 байтов).
Уменьшение длины фрагментов приводит к уменьшению вероятности
коллизии при передаче отдельно взятого фрагмента, но и к увеличению
количества фрагментов.

![Selection_041](https://github.com/octolera/OKS/assets/106665253/70d9cf0f-01ce-46da-a32a-58ab956452e6)

## 38. Кадры Wi-Fi
Наличие и названия последующих полей зависит от значения предыдущих.
Поля:

![Selection_042](https://github.com/octolera/OKS/assets/106665253/4513cca3-a97c-4f65-afda-e0e97e729446)

- `Frame Control` -- контроль кадра.
- `Duration/ID` -- длительность-идентификатор (0 -- 32767 us при
резервировании канала, трактовка зависит например от наличия QoS).
- `Address 1` -- адрес 1.
- `Address 2` -- адрес 2.
- `Address 3` -- адрес 3.
- `Sequence Control` -- контроль последовательности.
- `Address 4` -- адрес 4.
- `QoS Control` -- контроль QoS.
- `HT Control (High Throughput)` -- контроль интенсивной пересылки (при
QoS).
- `Frame Body` -- содержимое кадра (данные).
- `FCS (Frame Control Sequence)` -- контрольная сумма.

Поля контроля кадра:

- `Protocol Version` -- версия протокола (до сих пор равна нулю).
- `Type` -- тип: 00 -- Management -- управление, 01 -- Control -- контроль 10 -
- `Data` -- данные, 11 -- Reserved -- зарезервировано.
- `Subtype` -- подтип (в настоящее время определено около сорока
подтипов).
- `To DS` -- флаг направления в распределительную систему (проводную
систему, связывающую беспроводные сегменты).
- `From DS` -- флаг направления из распределительной системы.
- `More Fragments` -- флаг наличия фрагментации.
- `Retry` -- флаг повторной попытки передачи.
- `Power Management` -- флаг режима энергосбережения.
- `More Data` -- флаг наличия дополнительных данных (например,
буферизированных данных для находящейся в режиме энергосбережения
станции).
- `Protected Frame` -- флаг защищенности кадра (шифрования).
- `Order` -- флаг упорядоченности (при `QoS`).
  
Таким образом, существуют три типа кадров.

В зависимости от подтипа кадра в адресных полях могут
комбинироваться до четырех из пяти возможных адресов:
- `BSSID (Basic Service Set Identifier)` -- идентификатор так называемой
базовой зоны обслуживания (то есть беспроводного сегмента),
- `SA (Source Address)` -- адрес источника,
- `DA (Destination Address)` -- адрес назначения,
- `TA (Transmitting station Address)` -- адрес станции-передатчика
(непосредственного),
- `RA (Receiving station Address)` -- адрес станции-приемника (непосредственного).
  
## 39. Особенности детерминированных методов доступа к моноканалу
Если случайные методы уместно использовать при шинной топологии,
применительно к которой четко выражена возможность возникновения
коллизий, то детерминированные методы хорошо «ложатся» на кольцевую
топологию.
Концептуальная разница между случайными и детерминированными
методами заключается в том, возникает ли **случайность при «обращении»
станции к моноканалу**.

`Кольцо` можно рассматривать как своеобразный моноканал, один такт
работы которого представляет собой полный либо частичный «обход» кадром
всех станций.

Применительно к приведенной топологии, при доступе к моноканалу
никаких проблем казалось бы возникать не должно.
Действительно, физические коллизии для такой схемы невозможны, но
проявляется то, что можно назвать особым видом логических коллизий.
Если при некотором такте кольца какая-либо из станций имеет
собственный кадр для передачи и при этом получила из кольца еще один
кадр, который необходимо «продвигать» дальше, то появляется вопрос о том,
**какой из этих кадров передавать.**

Частично противоречие может быть разрешено буферизацией кадров. Но
возлагать на обычную пользовательскую станцию функции полноценного
сетевого моста канального уровня крайне нецелесообразно. Кроме того,
буферизация позволяет только «удерживать», то есть не терять кадры.
Сугубо алгоритмический вопрос о том, какой же из кадров (имеющийся кадр
для трансляции либо принятый кадр для ретрансляции) передавать раньше
все-таки оставляет без ответа.
Единственным способом преодоления логических коллизий является
введение приоритетов (priorities).
В то время как все случайные методы «завязаны» на генератор
случайных задержек, все детерминированные методы «завязаны» на систему
приоритетов в том или ином виде.
Возникает задача распределенного либо централизованного назначения
приоритетов, причем ни одна из станций кольца заранее ничего «не знает» о
других станциях.

При использовании механизма приоритетов не обойтись без так или
иначе выраженного арбитра.
В качестве арбитра может выступать специальный служебный кадр,
который в русскоязычной литературе обычно называют `маркером (token)`.

Таким образом, основные критерии классификации детерминированных
методов:
- централизованное либо распределенное управление;
- алгоритм назначения приоритетов;
- топологические особенности.

На эффективность детерминированных методов наиболее существенное
влияние оказывают те же факторы, что и в ситуациях со случайными
методами:
- количество взаимодействующих станций;
- частота синхронизации;
- длина кадра.

Если сравнивать детерминированные методы со случайными, то сложно
сказать какие из них «лучше». При применении случайных методов основные
потери производительности возникают из-за вносимых задержек, а при применении детерминированных
методов **потери обусловлены ретрансляцией кадров**.

Если оценивать реализации, которые уже имеются на рынке, то все же
**детерминированные алгоритмы в среднем демонстрируют большую
производительность**. Однако оборудование в среднем более дорогостоящее.

## 40. Алгоритм Token Ring
С точки зрения изучения детерминированных методов доступа к
моноканалу наиболее наглядным примером является классический алгоритм,
описанный в стандарте `Token Ring (IEEE 802.5)`.

В `Token Ring` применяется централизованное управление.
Закономерным следствием является необходимость включения в кольцо
по крайней мере одной управляющей станции, наделенной особыми
полномочиями и призванной инициализировать кольцо и следить за его
работоспособностью. В терминологии Token Ring такую управляющую
станцию обобщенно называют станцией-монитором (monitor station).
Кроме единственной основной станции-монитора (active monitor) в состав
кольца может входить некоторое количество резервных (standby monitors).
Функции станции-монитора:
- Инициализировать подключившиеся к кольцу станции.
- Тактировать (на физическом уровне) работу кольца.
- Контролировать наличие и валидность маркера.
- Предотвращать зацикливания.

В отличие от сегмента `Ethernet`, где все станции равноправны и действуют
по одному и тому же алгоритму, в сегменте Token Ring предусмотрены
станции несколько видов.
Наряду с выделяемыми на канальном уровне станциями-мониторами, на
более высоких уровнях рекомендуется выделять следующие станции:
- `System managers` -- системные менеджеры (на них сосредоточены
управляющие системой на основе Token Ring процессы).
- `Servers` -- различные серверы (configuration report servers, ring error
monitors, ring parameter servers).
- `Data stations` -- информационные станции (обычные пользовательские
станции).
Функциональное наполнение перечисленных видов станций выходит за
рамки стандарта.

```
Не смотря на то, что теоретически кольцо предполагает некоторую
возможность «распараллеливания» (то есть, одновременно по разным частям
кольца могут циркулировать несколько кадров), очень обобщенно алгоритм
Token Ring можно представить как «бесконечно» циркулирующий под
управлением станции-монитора маркер, который анализируется всеми
пользовательскими станциями и к которому при необходимости «цепляются»
данные.
```
## 41. Реализации детерминированных методов доступа к моноканалу
Для того чтобы понять заложенный в стандарт алгоритм, сначала
необходимо рассмотреть форматы кадров Token Ring и назначение основных
полей.
В
стандарте
предусмотрены
четыре
вида
передаваемых
последовательностей:
- `Token` -- маркер.
- `Frame` -- кадр.
- `Abort Sequence` -- прерывающая последовательность.
- `Fill` -- заполняющая последовательность.
Каждая из станций в любое время должна распознавать (и различать)
маркеры, кадры и специальные последовательности.

![Selection_043](https://github.com/octolera/OKS/assets/106665253/6b494634-5f9e-45e1-ae0e-0e0b1c908663)

Поля:
- `SD (Starting Delimiter)` -- начальный разделитель.
- `AC (Access Control)` -- контроль доступа.
- `FC (Frame Control)` -- контроль кадра.
- `DA (Destination Address)` -- адрес назначения.
- `SA (Source Address)` -- адрес источника.
- `RI (Routing Information)` -- информация о маршрутизации (может отсутствовать).
- `INFO (Information)` -- данные (могут отсутствовать).
- `FCS (Frame Check Sequence)` -- контрольная сумма.
- `ED (Ending Delimiter)` -- конечный разделитель.
- `FS (Frame Status)` -- состояние кадра.
- `IFG (InterFrame Gap)` – межкадровый интервал.

Формат маркера token ring

![Selection_044](https://github.com/octolera/OKS/assets/106665253/06c16204-ecc4-477d-aee5-98f3785ff223)

Формат прерывающей последовательности Token Ring

![Selection_045](https://github.com/octolera/OKS/assets/106665253/866d77be-b87c-4761-9d01-4d5c7e66025b)

`SD` и `ED` фактически являются флагами начала и конца кадра.
Между `IFG` и `SD` передается заполняющая последовательность.

Формат поля контроля доступа

![Selection_046](https://github.com/octolera/OKS/assets/106665253/7355dbe5-b740-4836-a434-87e3a0059c79)

Где:
`P (Priority bits)` -- текущий уровень приоритета.
`T (Token bit)` -- идентификатор маркера: 0 -- маркер, 1 -- кадр.
`M (Monitor bit)` -- бит монитора.
`R (Reservation bits)` -- запрашиваемый уровень приоритета.

Формат поля состояния кадра

![Selection_047](https://github.com/octolera/OKS/assets/106665253/0d8e1d03-aa34-4c29-8a96-ca139ecbc218)

Где:
`A (Address-recognized bit)` -- флаг распознания адреса (дублируется).
`C (frame-Copied bit)` -- флаг копирования кадра (дублируется).
`r (reserved)` -- зарезервировано.

## 42. Адресация в компьютерных сетях и классификация адресов
в форматах большинства пакетов присутствуют
два адреса:
- `Адрес назначения (destination address)`.
- `Адрес источника (source address)`.
В процессе пересылки пакета между абонентами адресация играет
ключевое значение.
Производительность СПД напрямую зависит от расположения адресов в
пакете. Поэтому адреса «выносят» в самое начало пакета. Более того,
поскольку с точки зрения доставки пакета адрес назначения является более
важным (в СПД анализируется именно этот адрес), он как правило
располагается раньше.

Многие топологии предполагают возможность приема переданного одной
из станций пакета всеми остальными станциями в пределах сегмента -- вне
зависимости от того, какой из станций пакет был предназначен. Следует
различать действия «принят станцией», «проанализирован станцией» и
«обработан станцией». Факт приема станцией пакета подразумевает, что
пакет будет проанализирован, но не подразумевает «полноценную»
обработку. Именно сравнение считанного из принятого пакета адреса
назначения со своим адресом, позволяет станции распознать пакет как
«свой».

Считанный из пакета адрес источника позволяет станции (при
необходимости) определить абонента, создавшего пакет.

Следует учитывать, что **важное влияние на адресацию оказывает
инкапсуляция**. Адресация всегда **«привязана» к некоторому протоколу**, а
**протокол**, в свою очередь, **«привязан» к уровню модели OSI**. Поэтому
закономерно, что на каждом из уровней присутствует **своя независимая
система адресации**.

Пакет, воспринятый как «свой» на одном из уровней, после его передачи
на более высокий уровень, там вполне может быть «отвергнут». Кроме того,
«окончательная» обработка не всегда происходит на прикладном уровне
(классический пример: ретрансляция пакета между сегментами при
маршрутизации).

В каждом пакете должны присутствовать по крайней мере адреса
канального уровня.
В большинстве же практических реализаций семейств протоколов, кроме
адресации на канальном уровне, предусмотрена адресация на сетевом (в
связке с транспортным) и прикладном уровнях.
Допустимость повторения адресов на одном уровне вытекает из цели
разработки определенного протокола.

**Адреса канального уровня «зашиваются» в сетевое оборудование при его
производстве** и поэтому повторяться не должны. Они не предполагают
возможность пользовательского вмешательства и их считают абсолютно
уникальными. Часто (в том числе Cisco) такую адресацию называют
`физической (physical)`.

**Адреса сетевого и прикладного уровней назначают пользователи**. Часто (в
том числе Cisco) такую адресацию называют `логической (logical)`.

В нормальной ситуации, по крайней мере в течение сеанса
взаимодействия, **адреса разных уровней одной станции должны
соответствовать друг другу**. Поэтому возникает необходимость в служебных
протоколах, отыскивающих эти соответствия.

Кроме всего прочего, даже на одном уровне модели OSI адресация может
быть `иерархической (hierarchical)`, то есть предполагать определенную
структуризацию соответствующего адресного пространства.

Иерархичность выражается в количественном и качественном разделении
адресов на типы.

Одним из примеров может служить связка адреса сетевого уровня с
адресом транспортного уровня.

В рамках функционирования сетевой ОС можно выделить объекты:
- `Сетевой процесс (network process)` -- представляет собой пару:
процессор и выполняющаяся на нем сетевая (то есть использующая сетевые
ресурсы) программа; причем, если меняется хотя бы один из этих
компонентов, то получается новый процесс.
- `Сетевой ресурс (network resource)` -- это любой компонент
вычислительной системы, который может быть предоставлен в пользование
сетевому процессу на определенное время.

Для того, чтобы взаимодействующие сетевые процессы могли найти друг
друга, во всех реальных системах используется три уровня адресации:
- Необходимо адресовать подсеть -- используется `адрес подсети (subnet
address)`.
- Необходимо адресовать станцию в подсети -- используется `адрес
станции (node address)`.
- Необходимо адресовать процесс в станции -- используется так
называемый адрес `программного порта (software port)`

Под адрес порта, как правило, отведено **два байта**.
При назначении программных портов **учитываются диапазоны**, к которым
они относятся.

Диапазоны программных портов применительно к семейству TCP/IP.
- `0-1023` - Well Known - предназначены для адресации основных сервисов в Internet.
- `1024-49151` - Registered - зарегистрированные дополнительные публичные сервисы
- `49152-65535` - Private and Dynamic - приватные и редкие сервисы

Специально для компьютерных сетей были разработаны четыре
основных способа адресации, которые заключаются в применении адресов
четырех базовых типов:
- `Юникаст (unicast)` -- пакет с таковым адресом назначения должен быть
обработан одной соответствующей станцией.
- `Бродкаст или, по-другому, широковещательных (brodcast)` -- пакет с
таковым адресом назначения должен быть обработан всеми станциями.
- `Мультикаст (multicast)` -- пакет с таковым адресом назначения должен
быть обработан несколькими станциями из множества.
- `Эникаст (anycast)` -- пакет с таковым адресом назначения должен быть
обработан одной станцией из множества.

По сути, **мультикаст- и эникаст-адреса** являются `групповыми
идентификаторами (Group IDs)`.

Специфика тех или иных типов накладывает ограничения на возможность
использования адресов.
Бродкаст-, мультикаст- и эникаст-адреса **не могут быть адресами
источников**, так как отдельно взятый пакет может сгенерировать только одна
станция.

Наиболее сложной формой адресации является **эникаст-адресация**.
Очевидно, что каждый раз при приеме эникаст-пакета должен
осуществляться выбор на основе какого-либо критерия. При этом
адресуемые станции должны осуществлять выбор в пределах группы сами.
Отправившая пакет станция не может принимать участие в алгоритме
выбора, она уже сделала свой «выбор» записав в пакет в качестве адреса
назначения эникаст-адрес. Выбор должен быть сделан заблаговременно,
чтобы принимающая станция была готова к поступлению в группу пакета.
Примером критерия выбора может служить время задержки.
Выбор может осуществляться однократно либо периодически.

## 43. MAC-адреса
В стандартах IEEE определены три базовых формата `MAC`-адресов: `MAC-
48`, `EUI-48` и `EUI-64`, где `EUI (Extended Unique Identifier)` -- расширенный
уникальный идентификатор.
`MAC-48` можно считать синонимом `EUI-48`, хотя изначально это было
более общее понятие.

Уникальность `MAC`-адресов контролирует **IEEE RA (IEEE Registration
Authority)**.

![Selection_048](https://github.com/octolera/OKS/assets/106665253/f62725ca-739a-48e2-8648-6a150874c49c)

Поля:
- `OUI (Organizationally Unique Identifier)` -- уникальный идентификатор
организации.
- `U/L (Universal/Local)` -- признак универсальности-локальности адреса.
- `I/G (Individual/Group)` -- признак индивидуального-группового адреса.
- `Extension Identifier` -- идентификатор-наполнитель.

`OUIs` выдают централизовано, уникальность оставшейся части должны
обеспечивать **сами организации (любым способом по своему усмотрению)**.
Время валидности адресов (время, которое нужно выдержать перед
повторным присвоением того же адреса другому устройству) определено **как
100 лет**.
Иногда, при администрировании, возникает необходимость подменить
адрес, «зашитый» в оборудование, на некий другой. Этот новый адрес
называют `локальным административным адресом (locally administered
address)`. Его признаком является **единичное значение бита U/L**.
Согласовывать значение остальных битов не требуется, но в пределах
сегмента адрес не должен повторяться.

Граница между `OUI` и `Extension Identifier` может проходить не только
посредине адреса. В общем случае предусмотрены три варианта
разрядности поля OUI:
- `MA-L (MAC Address -- Large)` -- 24 бита (данная схема использовалась
IEEE RA до 1 января 2014 г.)
- `MA-M (MAC Address -- Medium)` -- 28 битов (схема доступна после 1
января 2014 г.)
- `MA-S (MAC Address -- Small)` -- 36 битов (схема доступна после 1
января 2014 г.)

Иногда поле `OUI` рассматривают как `CID (Company ID)`, что, по большому
счету, то же самое -- зависит от комбинации значений битов `U/L` и `I/G`
(рассматривают уже как биты `X` и `M` соответственно).
При так называемом `каноническом представлении (canonical
representation)` `MAC`-адрес сдвигается в канал начиная со старших разрядов
(на рисунке слева).

По правилам IEEE MAC-адреса записывают в следующей нотации:

`XX-XX-XX-XX-XX-XX`

Где `X` -- шестнадцатеричная цифра (верхний регистр).
Но очень часто используют альтернативные нотации.

Примеры:

![Selection_049](https://github.com/octolera/OKS/assets/106665253/13571747-43c7-4630-b72b-1bda6a66c494)

Все `юникаст-MAC-адреса` должны иметь нулевое значение бита I/G.

`Групповые MAC-адреса` формируются по особым правилам, которые
будут рассмотрены позже.

В качестве `бродкаст-MAC-адреса` принято использовать значение
`FF-FF-FF-FF-FF-FF`.

Следует отметить, что `EUI-64` может использоваться **не только для
адресации, а и для просто идентификации устройств**.

Примеры технологий с применением `EUI-48`: `Ethernet`, `Wi-Fi`, `Token Ring`.

Примеры технологий с применением `EUI-64`: `IPv6`, `FireWire`.

## 44. Заголовок IPv4
В семействе `TCP/IP` за адресацию на сетевом уровне отвечает протокол
`IP`.

Заголовок протокола `IPv4 `(версии 4) имеет фиксированную структуру.

![Selection_050](https://github.com/octolera/OKS/assets/106665253/ae4eec26-26eb-4013-88d0-b9b1130d459a)

Поля:
- `Version` -- версия (значение равно 4).
- `IHL` (Internet Header Length) -- длина заголовка (в 32-ухбитных словах,
минимальное значение равно 5).
- `Type of Service` -- тип сервиса (связано с QoS).
- `Total Length` -- общая длина данных (в байтах, не может превышать 65535
байтов).
- `Flags` -- флаги.
- `Fragment Offset` -- смещение текущего фрагмента (в 64-ехбитных словах,
смещение первого фрагмента равно нулю).
- `Time to Live` -- «время жизни» (при каждой ретрансляции уменьшается,
когда становится равным нулю пакет уничтожается).
- `Protocol` -- протокол (инкапсулируемый в поле данных).
- `Header Checksum` -- контрольная сумма заголовка.
- `Source Address` -- адрес источника.
- `Destination Address` -- адрес назначения.
- `Options` -- опции (например, связанные с безопасностью, размер
вариативен).

### Поле Flags

![Selection_051](https://github.com/octolera/OKS/assets/106665253/3eeb4b04-8c63-4fd5-9c1e-74449628efd4)

Флаги:
- `DF (Don’t Fragment)`: 0 -- пакет фрагментирован, 1 -- пакет
нефрагментирован.
- `MF (More Fragments)`: 0 -- текущий фрагмент является последним, 1 --
текущий фрагмент не является последним.

## 45. Заголовок IPv6
Заголовок протокола `IPv6` имеет «гибкую» структуру.
Заголовки «каскадируются» -- сколько заголовков нужно, столько и
вставляется.

![Selection_052](https://github.com/octolera/OKS/assets/106665253/a92797c2-dc6f-46ae-a474-b11b2188b337)

Новые поля:
- `Traffic Class` -- класс трафика (связано с QoS).
- `Flow Label` -- метка потока (связано с QoS).
- `Payload Length` -- длина полезной нагрузки (в байтах, аналог поля Total
Length).
- `Next Header` -- селектор следующего заголовка (в том числе, аналог поля
Protocol).
- `Hop Limit` -- ограничитель числа «прыжков» (аналог поля Time to Live).

Полноценная реализация `IPv6` должна поддерживать следующие
заголовки:
- `IPv6 header` -- собственно IPv6-заголовок.
- `Hop-by-Hop Options header` -- заголовок опций ретрансляции.
- `Destination Options header` -- заголовок предназначенных станции
назначения опций.
- `Routing header` -- маршрутизационный заголовок.
- `Fragment header` -- заголовок франмента.
- `Authentication header` -- заголовок протокола AH (связано с защитой
информации).
- `Encapsulating Security Payload header` -- заголовок протокола ESP
(связано с защитой информации).
- `+8. Upper-layer header` -- заголовок протокола вышестоящего уровня.
Подробно IPv4- и IPv6-адресация будет рассмотрена в дальнейшем.

## 46. Протокол ARP
Группа протоколов под названием `ARPs (Address Resolution Protocols)`
предназначена для восстановления соответствий между `MAC`-адресами и `IP`-
адресами.
Под прямым преобразованием, собственно `ARP`, понимают нахождение
`MAC`-адреса по `IP`-адресу.
Обратное преобразование выполняется по протоколу `RARP (Reverse
ARP)`.
Существует еще `InARP (Inverse ARP)` и некоторые другие расширения.

![Selection_053](https://github.com/octolera/OKS/assets/106665253/bd5ea2d2-66b7-46db-bee9-28d8ac344526)

Поля:
- `Hrd (Hardware)` -- тип оборудования (1 -- Ethernet).
- `Pro (Protocol)` -- протокол (800h -- IP).
- `HLn (Hardware address Length)` -- длина аппаратного (физического) адреса
(в байтах, 6 -- Ethernet).
- `PLn (Protocol address Length)` -- длина протокольного (логического) адреса
(в байтах, 4 -- IP).
- `Op (Opcode)` -- код операции: 1 -- Request -- запрос, 2 -- Reply -- ответ (и
некоторые другие).
- `SHA (Sender Hardware Address)` -- аппаратный адрес запрашивающей
станции.
- `SPA (Sender Protocol Address)` -- протокольный адрес запрашивающей
станции.
- `THA (Target Hardware Address)` -- аппаратный адрес запрашиваемой
станции.
- `TPA (Target Protocol Address)` -- протокольный адрес запрашиваемой
станции.

## 47. Структура системы DNS
Протокол системы `DNS (Domain Name System)` (основные `RFCs` -- 1034 и
1035) предназначен для восстановления соответствий между `IP-адресами` и
`адресами прикладного уровня`.

![Selection_054](https://github.com/octolera/OKS/assets/106665253/745ffa27-df06-49b6-bb7d-2a33559356b3)

Система DNS соответствует клиент-серверной модели и включает три
основных компонента:
- `Адресное пространство доменных названий (domain name space)` и
записи о ресурсах -- RRs (Resource Records).
- `Серверы названий (name servers)`.
- `Программы, отвечающие на запросы клиентов (resolvers)`.

Каждый из этих компонентов «видит» систему `DNS` по-своему.

Адресное пространство доменных названий имеет иерархическую
древовидную структуру.

```
Следует отметить, что под доменом (domain, иногда cloud) в СПД
обобщенно понимают совокупность устройств, работающих в рамках
некоторых единых правил.
```

Каждый узел дерева на некотором уровне иерархии обозначают `DNS-
меткой (DNS label)` длиной от 0 до 63 байтов (должна начинаться с буквы и
состоять из комбинации букв любого регистра, цифр и символа -). Метка
нулевой длины зарезервирована и является корнем дерева. **При
присоединении станции к определенному домену ей так же присваивают
метку**.
Доменное название строится из меток -- в соответствии с путем к
корневой метке. **Полная длина не может превышать 255 байтов**.
Доменное название может относиться как к отдельно взятой станции, так
и к некоторой ветви дерева, то есть к `DNS-домену (DNS domain)`.
Доменное название может быть как `абсолютным (absolute)`, то есть
содержащим всю цепочку меток от станции до корневой метки, так и
`относительным (relative)`, то есть содержащим только часть меток.

**Внутреннее представление метки**: один байт, в котором указана длина
метки, за которым следуют собственно байты метки. При интерпретации
меток регистр букв не учитывается.

```
Изначально, когда сеть Internet была сосредоточена на территории США,
базовым критерием структуризации доменных названий Internet-сайтов
являлось целевое использование. Были зарегистрированы следующие
домены первого уровня -- TLDs (Top Level Domains): .arpa (ARPANET), .com
(commerce), .edu (education), .gov (government), .int (international), .mil
(military), .net (network), и .org (organization).
В дальнейшем, по мере расширения Internet, широкое распространение
получили национальные TLDs, например, .BY.
С недавнего времени основной упор сделан на продвижение
национальных языков (в качестве альтернативы английскому языку).
Зарегистрированы дополнительные национальные TLDs, например, .БЕЛ.
Четыре TLDs зарезервированы для специального использования:
.example, .invalid, .localhost, .test.
```

Серверы названий удерживают БД с записями о ресурсах.
Серверы названий делят на:
- `Авторитетные (authoritative, master)` -- являются первоисточниками
информации о некоторых частях системы DNS, называемых зонами (zones).
- `Вспомогательные (non-authoritative, slave)` -- работающие на основании
сведений от авторитетных серверов.

Таким образом, серверы так же образуют иерархию -- вплоть до наличия
корневых серверов.

**Каждой входящей в систему DNS станции (как и каждому домену)
соответствует некоторое количество RRs**.

Поля (по 16 бит):
- `NAME` -- доменное название (к которому относится RR, целевое при
поиске).
- `TYPE` -- тип.
- `CLASS` -- класс (семейство протоколов).
- `TTL (Time To Live)` -- «время жизни» (то есть время валидности RR, в
секундах).
- `RLENGTH (Resource LENGTH)` -- длина данных ресурса.
- `RDATA (Resource DATA)` -- данные ресурса (зависят от типа и класса)


Основные типы RRs:
- `A (A host address)` -- IP-адрес хоста.
- `NS (Name Server)` -- авторитетный сервер названий домена.
- `CNAME (Canonical NAME)` -- каноническое доменное название (станции
либо домена, для псевдонима).
- `SOA (Start Of a zone of Authority)` -- оригинальные параметры зоны
(сервер с изначальным описанием зоны, контактное лицо, время валидности
и другие).
- `NULL` -- нулевая запись (произвольная информация).
- `PTR (PoinTeR)` -- указатель -- доменное название станции (при
обратных преобразованиях).
- `HINFO (Host INFO)` -- информация о станции (процессор и ОС).
- `MX (Mail eXchange)` -- доменное название почтового сервера в домене
(включая приоритет, этот тип используется и вместо нескольких отмененных
типов).
- `TXT (TeXT strings)` -- текстовые строки (либо строка).
- `AAAA (--)` -- IPv6-адрес хоста (RFC 3596)
- `SRV (SeRVer selection)` -- описание сервиса (любого дополнительного
сетевого сервиса на станции, например, файлового) (RFC 2782).

И некоторые другие.

Классы `RRs`:
- `IN` -- Internet.
- `CS` -- CSNET (устарел и аннулирован).
- `CH` -- Chaosnet (устарел).
- `HS` -- Hesiod (для БД, очень редкий).

Остальные значения классов зарезервированы.


Примеры значений `RRs` класса `IN`:

`A`: 192.168.11.1.

`CNAME`: 5-508-fileserv.bsuir.by.

`MX`: 10 mail.bsuir.by.

`NS`: proxy1.bsuir.by.

`PTR`: 5-508-fileserv.bsuir.by.

## 48. Сообщения DNS
### Сообщение DNS
Поля:
- `Header` -- заголовок.
- `Question` -- вопрос.
- `Answer` -- ответ.
- `Authority` – авторитетный ответ.
- `Additional` -- дополнение.
  
Заголовок присутствует всегда, остальные поля вариативны.

### Заголовок DNS

![Selection_055](https://github.com/octolera/OKS/assets/106665253/67a74b2a-8b3f-4f32-bd2e-645381b45dde)

Поля:
- `ID (IDentifier)` -- идентификатор (программы, сгенерировавшей запрос).
- `QR (Query/Responce)` -- флаг запроса-ответа: 0 -- Query -- запрос, 1 --
Responce -- ответ.
- `OPCODE (OPeration CODE)` -- код операции (запроса):
-     0 -- QUERY (standard QUERY) -- стандартный запрос (о прямом преобразовании),
-     1 -- IQUERY (Inverse QUERY) -- запрос об обратном преобразовании (RFC 3425 отменен, альтернатива -- использование PTR RR),
-     2 -- STATUS (server STATUS request) -- запрос состояния сервера,
-     4 -- NOTIFY -- уведомление (об изменениях в БД о зоне) (RFC 1996),
-     5 -- UPDATE -- обновление (динамическое обновление БД о зоне) (RFC 2136),
-     6 -- DSO (DNS Stateful Operations) -- стабильные DNS-операции (альтернативный унифицированный синтаксис) (RFC 8490), остальные значения зарезервированы.
- `AA (Authoritative Answer)` -- флаг авторитетного ответа.
- `TC (TrunCation)` -- флаг «усеченности» сообщения (при слишком
длинном сообщении).
- `RD (Recursion Desired)` -- флаг желательной рекурсии (при обработке
запроса).8.0.7.16c
- `RA (Recursion Available)` -- флаг поддержки рекурсии.
- `Z (Zero)` -- нулевые биты (зарезервировано).
- `RCODE (Response CODE)` -- код ответа:
-     0 -- NoError (No Error) -- ошибок нет,
-     1 -- FormErr (Format Error) -- ошибка в формате,
-     2 -- ServFail (Server Failure) -- сбой сервера,
-     3 -- NXDomain (Non-eXistent Domain Name) -- доменное название не существует,
-     4 -- NotImp (Not Implemented) -- запрос не поддерживается,
-     5 -- Refused (Query Refused) -- запрос отклонен, остальные
значения относятся к расширениям `DNS` (RFC 2136, RFC 2845, RFC 2930,
RFC 4635, RFC 6672, RFC 6891, RFC 7873, RFC 8490) и зарезервированы.
- `QDCOUNT (Query DNS COUNT)` -- количество элементов (RRs) в поле
Question (обычно один).
- `ANCOUNT (ANswer COUNT)` -- количество элементов (RRs) в поле
Answer.
- `NSCOUNT (Name Server COUNT)` -- количество элементов (RRs) в
поле Authority.
- `ARCOUNT (Additional Records COUNT)` -- количество элементов (RRs)
в поле Additional.

### Поле Question

![Selection_056](https://github.com/octolera/OKS/assets/106665253/576c3b5f-0087-4164-ba7c-d242a4c9b8d0)

Поля:
- `QNAME (Query NAME)` -- доменное название в запросе.
- `QTYPE -- (Query TYPE)` -- тип запроса.
- `QCLASS (Query CLASS)` -- класс запроса.

Множество значений `QTYPE` является расширением множества значений
`TYPE`. Основные из новых типов:
- `251. IXFR (Incremental zone i.e. X transFeR)` -- запрос текущих изменений в
БД о зоне (от вспомогательного сервера авторитетному, по одноименному
протоколу) (RFC 1995).
- `252. AXFR (Authoritative zone i.e. X transFeR)` -- запрос полной БД о зоне
(по одноименному протоколу) (+RFC 5936).
- `255. *` -- запрос всех RRs.
- 
Множество значений `QCLASS` является расширением множества
значений `CLASS`. Новый класс:
- `255. *` -- любой класс.

## 49. Виртуальные соединения в сети передачи данных
Нужно отличать `виртуальные соединения (virtual connections)` от
`физических соединений (physical connections).`
Абоненты-программы физически (явно) соединены быть не могут.

Следовательно, применительно к ним, соединения являются **сугубо
виртуальными**.

Следует также учитывать, что нормальная готовность может
рассматриваться в двух ракурсах:
- Организация взаимодействия абонентов-программ.
- Настройка задействованного промежуточного оборудования.
В первом случае речь идет о собственно виртуальных соединениях
транспортного уровня, во втором -- о `виртуальных цепях (virtual circuits)`
сетевого или канального уровней.

В свою очередь, виртуальные цепи бывают:
- `PVCs (Permanent Virtual Circuits)` -- выделенные виртуальные цепи.
- `SVCs (Switched Virtual Circuits)` -- коммутируемые виртуальные цепи (в
отечественной литературе иногда называют виртуальными вызовами).

Термин `виртуальный канал (virtual channel)` может в равной степени
подходить как к виртуальным соединениям, так и к виртуальным цепям.

При разговоре о соединениях невозможно обойти стороной вопрос о
надежности.
Существуют два способа организации взаимодействия:
- **Без гарантированной доставки** -- в СПД предпринимаются
определенные усилия по доставке пакетов, но при этом ничего не
гарантируется (при необходимости, соответствующий контроль возлагается
на программы-абоненты).
- **С гарантированной доставкой** -- алгоритм работы транспортной службы
гарантирует доставку пакетов (программы-абоненты могут не контролировать
наличие и очередность пакетов).

Однако, соединение без гарантированной доставки практического смысла
не имеет. Поэтому наличие соединения как правило говорит о надежности.

В общем случае, контроль передачи информации посредством СПД
предотвращает не только потерю пакетов, но и искажение их содержимого.
Отсутствие соединения не означает, что защита от сбойных пакетов
отсутствует.

Простейшим подходом
к обеспечению контроля доставки
информационных пакетов является применение метода, который обобщенно
можно назвать методом `запросов-подтверждений (requests/acknowledges)`.

Метод предполагает некоторое разнообразие и заключается в том, что
вводят специальные служебные пакеты двух типов.

**Пакет-запрос** используется при получении права принять или передать
полезные данные, а также собственно при запросе данных.

**Пакет-подтверждение** (в отечественной литературе часто называют
квитанцией) передается в ответ на пакет-запрос или после приема полезных
данных.

Кроме того, при реализации метода запросов-подтверждений следует
учитывать следующие обстоятельства:
- инициатором взаимодействия может быть передатчик либо приемник
информационных пакетов;
-контроль может осуществляться передатчиком либо приемником, либо
передатчиком и приемником совместно;
- запросы либо подтверждения могут отсутствовать вообще;
- запросы могут комбинироваться с подтверждениями;
- запрашиваться и подтверждаться может все сообщение либо каждый из
пакетов;
- подтверждаться могут не только информационные, а и служебные
пакеты;
- квитанции могут быть как положительными, так и отрицательными;
- факт потери пакета может определяться и обрабатываться по-разному.

Таким образом, не смотря на сохранение идеологии, практические
реализации метода запросов-подтверждений могут сильно различаться.


Функционирование механизма запросов-подтверждений подразумевает
ожидание определенных событий. Ожидание, в любом случае, не должно
затягиваться до бесконечности.

Ограничение ожидания во времени достигается за счет применения
`тайм-аута (time-out)`. После передачи некоторого служебного или
информационного пакета, требующего подтверждения, запускается таймер с
обратным отсчетом. Если в течение заданного интервала времени
соответствующая квитанция не приходит, то пакет считается утерянным и
передается повторно (retransmission). Если квитанция не приходит снова и
снова, то после некоторого конечного количества попыток дальнейшая
передача считается бесперспективной и прекращается.

![Selection_057](https://github.com/octolera/OKS/assets/106665253/66594c88-e329-4e0f-b74d-2b4ceefeb043)

Следует учитывать, что:
- теряться могут как информационные пакеты, так и квитанции и пакеты-
запросы;
- если квитанция приходит позже наступления тайм-аута, то этот факт
приравнивается к ее потере;
- оптимальное время ожидания квитанций, применительно к некоторой
СПД, зависит от ее особенностей.

## 50. Классификация оконных механизмов, используемых в сети передачи данных
В случае, когда СПД загружена незначительно, а взаимодействующие
абоненты расположены далеко друг от друга, задействование классического
механизма
запросов-подтверждений
приводит
к
неэффективному
использованию ресурсов. Время, затрачиваемое на ожидание квитанций,
становится недопустимо большим в сравнении с временем, затрачиваемым
на передачу полезных данных.

Оптимизировать обмен позволяет применение `оконного (window) метода`,
суть которого состоит в том, что до перехода к ожиданию квитанций
передается не один, а несколько пакетов.

Выделяют два основных критерия классификации оконных методов.
Исходя из количества пакетов, передаваемых в окне, оно может быть:
- `Статическим (static)` -- неизменяемый размер окна заложен в протокол
или устанавливается на весь сеанс обмена.
- `Динамическим (dynamic)` -- размер окна может изменяться
(увеличиваться или уменьшаться) в процессе передачи сообщения.

Исходя из способа обработки очереди пакетов, окно может быть:
- `Фиксированным (fixed)` -- перед формированием следующего окна
текущее должно быть полностью «закрыто», то есть должны быть приняты
все необходимые квитанции.
- `Скользящим (sliding)` -- существует возможность сдвигать окно
относительно последовательности пакетов.

При реализации оконного метода следует учитывать следующие
дополнительные обстоятельства:
- нужна нумерация пакетов в том или ином виде;
- подтверждаться может как все окно, так и каждый из пакетов;
- размером окна может управлять как передатчик, так и приемник;
- размером окна можно управлять посредством служебных полей, в том
числе и в информационных пакетах;
- окно, с которым работает передатчик, может отличаться от окна, с
которым работает приемник;
- иногда важен порядок доставки пакетов

С точки зрения реализации, наиболее простым является `статическое окно
фиксированного размера`. Основной его недостаток состоит в отсутствии возможности адаптации к
изменениям в СПД.

![Selection_058](https://github.com/octolera/OKS/assets/106665253/e00b6ab1-4401-4cc0-b6c4-192d735e55c7)

Первым вариантом усложнения является переход к `динамическому окну`. Динамическое окно позволяет успешно адаптироваться к изменениям в
СПД. При увеличении загруженности окно целесообразно сужать, а при
снижении -- расширять.

![Selection_059](https://github.com/octolera/OKS/assets/106665253/09a6ac07-8bfc-44c0-91a4-3aa2b1ba1020)

Вторым вариантом усложнения является переход к `скользящему окну`. Вторым вариантом усложнения является переход к скользящему окну.

![Selection_060](https://github.com/octolera/OKS/assets/106665253/b2f09dd9-895e-4f3d-8376-a9595e0c5867)

Классической реализацией оконного метода является оконный механизм
протокола транспортного уровня `TCP (Transmission Control Protocol)`
(основное RFC -- RFC 793).
Протокол обеспечивает установление надежного соединения между
сугубо пользовательскими или другими видами приложений, то есть доставка
данных в правильном порядке гарантируется.

В стандарте TCP описано `динамическое скользящее окно`.

## 51. Структура системы TCP
`TCP` соответствует клиент-серверной модели.

`Сокет (socket)` -- это «привязка» к виртуальному каналу, соединяющему
между собой два взаимодействующих сетевых процесса, с точки зрения
одного (любого) из этих процессов, причем с учетом всех трех уровней
адресации.

![Selection_061](https://github.com/octolera/OKS/assets/106665253/16a603ab-34e3-4280-807b-18062b2133ef)

Применительно к каждому `TCP`-соединению **нужно выделять приложение**,
производящее или потребляющее сетевые данные, и `TCP-процесс`,
предоставляющий коммуникационные услуги (например, специальный
драйвер ОС).

Синхронизировать работу приложения и `TCP-процесса` можно только с
помощью `буферизации`.
`TCP-интерфейс`, которым пользуется приложение, состоит из примитивов
для работы с буфером, позволяющих контролируя записывать или считывать
данные.
**Доступ к буферу** имеет и `TCP-процесс`, который отслеживает наполнение
буфера и, используя ресурсы более низких уровней, организует прием или
передачу данных.

Предназначенное для передачи **сообщение** разбивается на `сегменты`.
Минимальной учитываемой в окне единицей данных является октет, то
есть байт.

Все байты сообщения последовательно нумеруются так называемыми
последовательными номерами -- `SNs (Sequence Numbers)`.

Нумерация начинается с некоторого начального последовательного
номера -- `ISN (Initial Sequence Number)`, который как правило не равен нулю, а
генерируется реализациями случайно (например, на основе текущего
времени) для того чтобы лучше управлять соединениями (например, после их
ненормальных завершений).

Принято, что сам `ISN` в нумерацию байтов не включается, то есть номер
первого байта сообщения больше `ISN` на единицу.
Номером сегмента является `SN` первого байта данных в нем.

По разным понятным причинам длина сегмента может варьировать, но
она имеет ограничение. Поэтому важное значение имеет конфигурационный
параметр `MSS (Maximum Segment Size)` -- максимальная длина сегмента **(по
умолчанию 536 байтов)**.

Cегментация сообщения

![Selection_062](https://github.com/octolera/OKS/assets/106665253/477d0db2-fa30-41d7-ae0f-d01b18a3be3b)

В стандарте выделяют несколько видов окон, которые нужно различать.
Благодаря гибкости протокола, передающий и принимающий TCP-
процессы работают с разными окнами, то есть, в первую очередь, следует
отдельно рассматривать `окно передачи (send window)` и `окно приема (receive
window)`.

Организация буфера отправки

![Selection_063](https://github.com/octolera/OKS/assets/106665253/62a09f95-8daf-4d83-b564-b90f9716e99c)

Передающее приложение последовательно, «порциями», записывает
блоки байтов сообщения, возможно разной длины, в буфер передачи.
Длина сообщения и размер буфера -- это вещи независимые, они почти
всегда различаются.

`TCP-процесс` формирует из имеющихся в буфере данных
соответствующее количество сегментов и последовательно отправляет их.
В любой момент времени `текущее окно (current window)` передачи имеет
**некоторый установленный размер** и характеризуется тем, что **все
попадающие в него сегменты с данными можно передавать без ожидания
подтверждений**.

Его правая (на рисунке) граница совпадает с правой границей буфера и
скользит налево относительно последовательности сегментов с данными по
мере поступления и упорядочивания подтверждений.

Переданные, но неподтвержденные сегменты с данными **продолжают
оставаться в буфере**, так как возможно потребуется их повторная передача.

Левая граница «привязана» к правой в соответствии с размером текущего
окна. Но поскольку размер подвержен динамической коррекции, положение
левой границы относительно правой постоянно изменяется.

Область текущего окна передачи за вычетом переданных, но
неподтвержденных сегментов с данными, является `доступным окном (useable
равно effective window)`.

`TCP-процесс` должен последовательно отправить все сегменты с
данными, попавшие в эту область.

**Если размер текущего окна передачи равен нулю, то передача
приостанавливается полностью**.

Организация буфера приёма

![Selection_064](https://github.com/octolera/OKS/assets/106665253/0174ca6c-adf8-4ba2-b3b9-37dd772bd4a2)

На другой стороне соединения, возможно уже разупорядоченные при
преодолении СПД сегменты поступают в буфер приема (размер может не
совпадать с размером буфера передачи). При этом они размещаются там
согласно своим номерам.

Текущее окно приема охватывает часть буфера, в которой можно
размещать еще неупорядоченные сегменты с данными.
Как и текущее окно передачи, в любой момент времени оно так же имеет
некоторый определенный размер.

Левая (на рисунке) граница текущего окна приема совпадает с левой
границей буфера.

Правая граница проходит слева за последним упорядоченным сегментом
с данными и поэтому динамически меняет свое положение относительно
левой границы.

По мере считывания принимающим приложением упорядоченных байтов
из буфера окно скользит относительно последовательности сегментов с
данными.

**Если размер текущего окна приема равен нулю, а сегменты с данными
продолжают поступать, то возникает переполнение**.

Вполне закономерно, что именно на принимающий `TCP-процесс`, как на
более подверженный влиянию недетерминированности СПД, возложен
контроль «поведения» оконного механизма. Это делается посредством
«обратной связи». Принимающий `TCP-процесс` **пытается информировать
передающий о состоянии своего буфера**, точнее о наличии в нем свободного
места. Для этого он при подтверждениях сообщает `предлагаемое окно
(announced равно advertised равно offered window)`.
**В качестве размера предлагаемого окна указывается размер текущего
окна приема**. Последствия разупорядочивания сегментов с данными такому
подходу не противоречат.

**Максимальный размер любого из окон не может превышать размер
соответствующего буфера (например, 8 килобайтов)**.

В результате, можно сделать вывод о том, что на работу соединения
влияют приложения, `TCP-процессы` и сетевой уровень.
В идеале, при полностью сбалансированной работе, размер текущего
окна передатчика равен размеру предлагаемого окна, то есть равен размеру
текущего окна приемника. А если еще и буферы освобождаются «мгновенно»,
то этот размер совпадает с размером доступного окна и размерами буферов.

**Алгоритмы TCP направлены на «уравнивание» всех упомянутых окон**.

## 52. Заголовок TCP

![Selection_065](https://github.com/octolera/OKS/assets/106665253/4e907021-1b0c-4e74-97e7-751e5ce570c4)

Поля:
1. `Source Port` -- программный порт источника.
2. `Destination Port` -- программный порт назначения.
3. `Sequence Number (SN)` -- последовательный номер (сегмента).
4. `Acknowledgment Number (AN)` -- подтверждающий номер.
5. `Data Offset` -- смещение данных (в 32-ухбитных словах).
6. `Reserved` -- зарезервировано (должно равняться нулю).
7. `URG (URGent Pointer field significant)` -- флаг значимости указателя на
экстренные данные.
8. `ACK (ACKnowledgment field significant)` -- флаг значимости
подтверждающего номера.
9. `NS (Nonce Sum)` -- флаг -- контрольная сумма для проверки
правильности кодов явных уведомлений о заторах (связан с QoS, связан с IP-
заголовком) (RFC 3540).
10. `CWR (Congestion Window Reduced)` -- флаг уменьшения окна затора
при явном уведомлении о заторе (RFC 3168).
11. `ECE (Explicit Congestion Notification Echo)` -- флаг подтверждения
явного уведомления о заторе (RFC 3168).
12. `PSH (PuSH Function)` -- флаг принудительной доставки данных (без
буферизации).
13. `RST (ReSeT the connection)` -- флаг разрыва соединения (например,
из-за сбоя на одной из взаимодействующих сторон).
14. `SYN (SYNchronize sequence numbers)` -- флаг синхронизации
последовательных номеров.
15. `FIN (No more data from sender)` -- флаг последних данных.
16. `Window (W)` -- предлагаемое окно.
17. `Checksum` -- контрольная сумма.
18. `Urgent Pointer` -- указатель на экстренные данные (RFC 6093).
19. `Options` -- опции (например, MSS).
20. `Padding` -- наполнитель
    
## 53. Протокол TCP
Функционирование оконного механизма
`TCP` базируется на использовании трех полей в заголовке сегмента: `SN`, `AN`, `W`, и трех флагов (из
шести стандартизованных изначально): `SYN`, `ACK`, `FIN`.

Установление `TCP`-соединения, известное как `«тройное рукопожатие»
(three-way handshake)`, основывается на использовании флагов `SYN` и `ACK`.

![Selection_066](https://github.com/octolera/OKS/assets/106665253/c1cb167a-6cf1-4d38-8788-a63a76c64278)

Сначала `TCP`-процесс -- инициатор взаимодействия (на стороне клиента)
отправляет служебный сегмент с установленным флагом SYN, тем самым
сообщая о своих намерениях (первое «рукопожатие»).

Затем запрашиваемый `TCP`-процесс (на стороне сервера), если он
согласен взаимодействовать, подтверждает это ответным служебным
сегментом с двумя установленными флагами `SYN` и `ACK` (второе
«рукопожатие»).

Наконец, инициатор отвечает еще одним служебным сегментом с
установленным флагом `ACK`, тем самым подтверждая подтверждение (третье
«рукопожатие»).

Не смотря на то, что процесс установления соединения несимметричен, в
дальнейшем, в общем случае, оно используется в полнодуплексном режиме.

![Selection_067](https://github.com/octolera/OKS/assets/106665253/c6319cce-e4c6-42fb-9cc4-c2e61a69bcd0)

Очень важно, что на обмен сегментами нужно смотреть с двух сторон.
При этом один и тот же TCP-процесс, находящийся по одну сторону
соединения, одновременно может выступать в качестве как передатчика
данных, так и приемника данных.

Полнодуплексность самого соединения достигается за счет того, что
передаваемый в определенном направлении сегмент служит одновременно
для транспортировки как данных и связанных с ними служебных полей от
передающей составляющей TCP-процесса, так и подтверждений и связанных
с ними других служебных полей от принимающей составляющей TCP-
процесса.

В СПД одновременно могут находиться множество сегментов,
относящихся к одному соединению.
Применительно к данным в одном сегменте, соединение является
полудуплексным, так как сегмент не может содержать более одного поля с
ними.

По правилу протокола, поле `SN` пересылаемого сегмента отражает
собственный `SN` этого сегмента.
По другому правилу, в поле `AN` указывается `SN` ожидаемого сегмента,
коим является следующий по порядку сегмент.

При установлении соединения данные не пересылаются. Поэтому, для
того чтобы не нарушать указанные правила, в качестве `SNs` используют
невключенные в нумерацию байтов сообщения `ISNs`, а в качестве `ANs` --
просто инкрементированные `SNs`. Обойтись без передачи `SNs` при
установлении соединения невозможно, так как стороны должны однозначно
идентифицировать это соединение.

После синхронизации SNs соединение считается `установленным
(established)`.

**Флаг SYN используется только при установлении соединения, а флаг ACK
-- в каждом ответном сегменте**.

```
Не смотря на предоставляемые возможности, данные вполне могут
пересылаться только в одном направлении, то есть в симплексном режиме.
При этом в направлении, попутном направлению пересылки данных, в
качестве AN используется SN следующего по порядку несуществующего
(вообще, либо уже, либо пока) сегмента, что никоим образом не противоречит
уже приведенным правилам.
Если сегментов с данными пересылается несколько, то ANs дублируются
столько раз, сколько нужно.
Это приводит к дублированию SNs в ответных сегментах без данных.
Аналогичные дублирования возникают и при приостановке пересылки
данных в определенном направлении.
```

Поскольку при установлении соединения оно всегда открывается в двух
направлениях (по инициативе клиента, но может использоваться в одном
любом направлении), для нормального завершения оно и закрыто должно
быть в обоих направлениях.

Для закрытия соединения в своем направлении, сторона, в
соответствующем сегменте (обычно с последними данными), устанавливает
флаг `FIN`.

![Selection_068](https://github.com/octolera/OKS/assets/106665253/e558fd41-cb57-47d8-b69c-3d3054a508cd)

**Соединение, нормально закрытое только в одном направлении, или
ненормально завершенное на одной из сторон без уведомления другой
стороны (в результате сбоя) называют** `полуоткрытым (half-open)`.

Размер предлагаемого окна в поле `W `может изменяться каждый раз для
соответствующей коррекции текущего окна передачи, в том числе и при
установлении соединения для изменения размера текущего окна передачи по
умолчанию.

![Selection_069](https://github.com/octolera/OKS/assets/106665253/7f94a28a-3172-46fa-ac83-b3046b45acd3)

В случае задания нулевого значения поля `W` передача данных
фактически запрещается. После освобождения места в буфере приема
подтверждение обязательно повторяется с уже ненулевым полем `W`, что
«разблокирует» передающую сторону.

Проблема возможной потери в СПД некоторых сегментов решается с
помощью `тайм-аутов`.

![Selection_070](https://github.com/octolera/OKS/assets/106665253/b47e533b-42c4-457a-95ca-873bc44598c9)

**Передающий TCP-процесс** определяет потерю сегмента с данными либо
его подтверждения по отсутствию этого подтверждения в течение
установленного интервала времени. После наступления тайм-аута сегмент с
данными передается повторно. Отрицательные подтверждения не предусмотрены вообще.

**Принимающий TCP-процесс** подтверждает все принятые сегменты с
данными, причем подтверждает всегда. При этом если принята копия (что
говорит о потере подтверждения), то она удаляется.
Получение сегмента с SN больше ожидаемого говорит о возможной
потере сегментов с данными или о разупорядочивании.

Важно правильно оценивать время «отклика системы». Поэтому время
ожидания подтверждений рассчитывается на основе показаний таймеров и
корректируется.

При этом первостепенное значение имеет параметр `RTT (Round-Trip
Time)` -- **суммарное время пересылки по СПД сегмента с данными и его
подтверждения**.

## 54. Усовершенствования протокола TCP
Протокол `TCP` обладает несколькими дополнительными возможностями. Возможна пересылка `экстренных данных (urgent data)` и `ускоренная пересылка (push function)`.

В частности, хорошо известна проблема, вошедшая в историю под
обобщенным названием `«синдром глупого окна» («silly window syndrome»)`, в
свое время «стопорившая» значительную часть пространства Internet.
Синдром может возникать по разным причинам и проявляется в том, что
текущее окно передачи не соответствует состоянию приемника, тем самым не
позволяя его как следует «нагрузить» либо, наоборот, «разгрузить».

**Решение Нэгла (Nagle)** позволяет побороть «синдром глупого окна» когда
передающей стороне требуется часто отправлять небольшие сегменты с
данными.

**Решение Кларка (Clark)** позволяет побороть «синдром глупого окна» когда
принимающей стороной часто анонсируется небольшое предлагаемое окно.

Также стандартизированы четыре дополнения Ван Якобсона (Van
Jacobson), **призванные бороться с перегрузками в СПД** (последнее RFC --
RFC 5681):

1. `Медленный старт (slow start)`.
Идея заключается в том, что в начале передачи размер текущего окна
передачи нужно увеличивать не «скачком», а плавно, пропорционально
скорости получения подтверждений (не превышая размер предлагаемого
окна).

Рекомендуемые формулы:
    `IW = 2 * SMSS, если SMSS > 2190 Bytes` ,
    `IW = 3 * SMSS, если 2190 Bytes >= SMSS > 1095 Bytes` ,
    `IW = 4 * SMSS, если SMSS <= 1095 Bytes` ,
где `IW (initial window) `-- начальное значение текущего окна передачи:
    `cwnd += min (N, SMSS)` ,
где `cwnd (congestion window)` -- текущее окно передачи (в данном случае,
окно затора),`N` -- количество подтвержденных байтов, `SMSS (sender MSS)` --
`MSS` передатчика.

2. `Избегание затора (congestion avoidance)`.
Состоит в сдерживании экспоненциального роста размера текущего окна
передачи после преодоления им некоторого порога. Как правило переход к
избеганию затора происходит после медленного старта.

   Рекомендуемые формулы:

   `ssthresh = max (FlightSize / 2, 2 * SMSS) `,

где `ssthresh (slow start threshold)` -- порог перехода от медленного старта к
избеганию затора, `FlightSize` -- количество еще неподтвержденных байтов;

    `cwnd += SMSS * SMSS / cwnd` .

4. `Быстрая повторная передача (fast retransmit)`.
При получении принимающей стороной разупорядоченного сегмента с
данными (возможно из-за потери ожидаемого сегмента с данными)
незамедлительный повтор подтверждения с AN недостающего сегмента с
данными. При получении передающей стороной трех одинаковых
подтверждений незамедлительный повтор сегмента с данными согласно `AN`.
Что, в некоторых ситуациях, позволяет успешно переслать потерянный
сегмент еще до наступления тайм-аута.

![Selection_072](https://github.com/octolera/OKS/assets/106665253/52e59eac-cadd-41ad-8868-495528a57b8e)

4. `Быстрое восстановление (fast recovery)`.
После обнаружения затора, переход сразу к избеганию коллизий, минуя
стадию медленного старта. Как правило в связке с быстрой повторной
передачей.

![Selection_073](https://github.com/octolera/OKS/assets/106665253/cb54af2b-2057-4e6a-a50d-51e882e84ae5)

**Последствия потерь и разупорядочивания сегментов** заключаются в
разрушении «маятника» взаимодействия и приводят к необходимости еще
одной важной оптимизации, четко проявляющейся при быстрой повторной
передаче.
Согласно базовому алгоритму все сегменты должны быть подтверждены,
а значит, после быстрой повторной передачи принимающая сторона должна
послать все недостающие подтверждения.
Но стороны могут «договориться», что текущий AN отражает номер
первого ожидаемого получателем сегмента плюс
`автоматически
подтверждает все сегменты с меньшими номерами (cumulative
acknowlegement)`.

## 55. Протокол UDP и заголовок UDP
Протокол транспортного уровня `UDP (User Datagram Protocol)` (RFC 768)
реализует способ пересылки данных **без гарантии доставки**, часто
называемый `дейтаграммным (datagram) (хотя user datagram -- это пакет с
контролируемыми пользователем данными, а datagram -- это любой пакет с
данными)`.

![Selection_074](https://github.com/octolera/OKS/assets/106665253/2a8f5b99-06c0-4150-9af5-9972fe4ce131)

Поля:
- `Source Port` -- программный порт источника.
- `Destination Port` -- программный порт назначения.
- `Length` -- длина дейтаграммы включая заголовок (в байтах).
- `Checksum` -- контрольная сумма (псевдозаголовка, плюс заголовка, плюс
данных).

**При вкладывании UDP-дейтаграммы в IP-пакет (IPv4, IPv6), между UDP-
заголовком и IP-заголовком вставляется дополнительный так называемый
UDP-псевдозаголовок, в котором дублируются некоторые значения из
основного IP-заголовка**.

## 56. Классификация и характеристики сред передачи данных
## 57. Среды передачи данных на основе коаксиальных кабелей
## 58. Среды передачи данных на основе витых пар
## 59. Среды передачи данных на основе оптоволоконных кабелей
## 60. Физический уровень Ethernet
## 61. Структурированные кабельные системы и их модели
## 62. Питание и заземление в структурированных кабельных системах
## 63. Пожарная безопасность структурированных кабельных систем
## 64. Технология PoE
# Практические (задания) 
## 65. Структура системы FTP
## 66. Протокол FTP и режимы обмена по протоколу FTP
## 67. Структура и особенности системы Telnet
## 68. Электронные письма и почтовые ящики
## 69. Обобщенная структура системы электронной почты
## 70. Почтовые агенты
## 71. Протокол SMTP и его расширения
## 72. Протокол POP3 и его расширения
## 73. Протокол IMAP и его расширения
## 74. Структура системы HTTP
## 75. Ресурсы в системе HTTP
## 76. Заголовки HTTP
